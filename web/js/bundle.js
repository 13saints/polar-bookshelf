/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/web/js";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./web/js/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/TextHighlighter.js":
/*!********************************!*\
  !*** ./lib/TextHighlighter.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function (global) {\n    'use strict';\n\n    var\n        /**\n         * Attribute added by default to every highlight.\n         * @type {string}\n         */\n        DATA_ATTR = 'data-highlighted',\n\n        /**\n         * Attribute used to group highlight wrappers.\n         * @type {string}\n         */\n        TIMESTAMP_ATTR = 'data-timestamp',\n\n        NODE_TYPE = {\n            ELEMENT_NODE: 1,\n            TEXT_NODE: 3\n        },\n\n        /**\n         * Don't highlight content of these tags.\n         * @type {string[]}\n         */\n        IGNORE_TAGS = [\n            'SCRIPT', 'STYLE', 'SELECT', 'OPTION', 'BUTTON', 'OBJECT', 'APPLET', 'VIDEO', 'AUDIO', 'CANVAS', 'EMBED',\n            'PARAM', 'METER', 'PROGRESS'\n        ];\n\n    /**\n     * Returns true if elements a i b have the same color.\n     * @param {Node} a\n     * @param {Node} b\n     * @returns {boolean}\n     */\n    function haveSameColor(a, b) {\n        return dom(a).color() === dom(b).color();\n    }\n\n    /**\n     * Fills undefined values in obj with default properties with the same name from source object.\n     * @param {object} obj - target object\n     * @param {object} source - source object with default values\n     * @returns {object}\n     */\n    function defaults(obj, source) {\n        obj = obj || {};\n\n        for (var prop in source) {\n            if (source.hasOwnProperty(prop) && obj[prop] === void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n\n        return obj;\n    }\n\n    /**\n     * Returns array without duplicated values.\n     * @param {Array} arr\n     * @returns {Array}\n     */\n    function unique(arr) {\n        return arr.filter(function (value, idx, self) {\n            return self.indexOf(value) === idx;\n        });\n    }\n\n    /**\n     * Takes range object as parameter and refines it boundaries\n     * @param range\n     * @returns {object} refined boundaries and initial state of highlighting algorithm.\n     */\n    function refineRangeBoundaries(range) {\n        var startContainer = range.startContainer,\n            endContainer = range.endContainer,\n            ancestor = range.commonAncestorContainer,\n            goDeeper = true;\n\n        if (range.endOffset === 0) {\n            while (!endContainer.previousSibling && endContainer.parentNode !== ancestor) {\n                endContainer = endContainer.parentNode;\n            }\n            endContainer = endContainer.previousSibling;\n        } else if (endContainer.nodeType === NODE_TYPE.TEXT_NODE) {\n            if (range.endOffset < endContainer.nodeValue.length) {\n                endContainer.splitText(range.endOffset);\n            }\n        } else if (range.endOffset > 0) {\n            endContainer = endContainer.childNodes.item(range.endOffset - 1);\n        }\n\n        if (startContainer.nodeType === NODE_TYPE.TEXT_NODE) {\n            if (range.startOffset === startContainer.nodeValue.length) {\n                goDeeper = false;\n            } else if (range.startOffset > 0) {\n                startContainer = startContainer.splitText(range.startOffset);\n                if (endContainer === startContainer.previousSibling) {\n                    endContainer = startContainer;\n                }\n            }\n        } else if (range.startOffset < startContainer.childNodes.length) {\n            startContainer = startContainer.childNodes.item(range.startOffset);\n        } else {\n            startContainer = startContainer.nextSibling;\n        }\n\n        return {\n            startContainer: startContainer,\n            endContainer: endContainer,\n            goDeeper: goDeeper\n        };\n    }\n\n    /**\n     * Sorts array of DOM elements by its depth in DOM tree.\n     * @param {HTMLElement[]} arr - array to sort.\n     * @param {boolean} descending - order of sort.\n     */\n    function sortByDepth(arr, descending) {\n        arr.sort(function (a, b) {\n            return dom(descending ? b : a).parents().length - dom(descending ? a : b).parents().length;\n        });\n    }\n\n    /**\n     * Groups given highlights by timestamp.\n     * @param {Array} highlights\n     * @returns {Array} Grouped highlights.\n     */\n    function groupHighlights(highlights) {\n        var order = [],\n            chunks = {},\n            grouped = [];\n\n        highlights.forEach(function (hl) {\n            var timestamp = hl.getAttribute(TIMESTAMP_ATTR);\n\n            if (typeof chunks[timestamp] === 'undefined') {\n                chunks[timestamp] = [];\n                order.push(timestamp);\n            }\n\n            chunks[timestamp].push(hl);\n        });\n\n        order.forEach(function (timestamp) {\n            var group = chunks[timestamp];\n\n            grouped.push({\n                chunks: group,\n                timestamp: timestamp,\n                toString: function () {\n                    return group.map(function (h) {\n                        return h.textContent;\n                    }).join('');\n                }\n            });\n        });\n\n        return grouped;\n    }\n\n    /**\n     * Utility functions to make DOM manipulation easier.\n     * @param {Node|HTMLElement} [el] - base DOM element to manipulate\n     * @returns {object}\n     */\n    var dom = function (el) {\n\n        return /** @lends dom **/ {\n\n            /**\n             * Adds class to element.\n             * @param {string} className\n             */\n            addClass: function (className) {\n                if (el.classList) {\n                    el.classList.add(className);\n                } else {\n                    el.className += ' ' + className;\n                }\n            },\n\n            /**\n             * Removes class from element.\n             * @param {string} className\n             */\n            removeClass: function (className) {\n                if (el.classList) {\n                    el.classList.remove(className);\n                } else {\n                    el.className = el.className.replace(\n                        new RegExp('(^|\\\\b)' + className + '(\\\\b|$)', 'gi'), ' '\n                    );\n                }\n            },\n\n            /**\n             * Prepends child nodes to base element.\n             * @param {Node[]} nodesToPrepend\n             */\n            prepend: function (nodesToPrepend) {\n                var nodes = Array.prototype.slice.call(nodesToPrepend),\n                    i = nodes.length;\n\n                while (i--) {\n                    el.insertBefore(nodes[i], el.firstChild);\n                }\n            },\n\n            /**\n             * Appends child nodes to base element.\n             * @param {Node[]} nodesToAppend\n             */\n            append: function (nodesToAppend) {\n                var nodes = Array.prototype.slice.call(nodesToAppend);\n\n                for (var i = 0, len = nodes.length; i < len; ++i) {\n                    el.appendChild(nodes[i]);\n                }\n            },\n\n            /**\n             * Inserts base element after refEl.\n             * @param {Node} refEl - node after which base element will be inserted\n             * @returns {Node} - inserted element\n             */\n            insertAfter: function (refEl) {\n                return refEl.parentNode.insertBefore(el, refEl.nextSibling);\n            },\n\n            /**\n             * Inserts base element before refEl.\n             * @param {Node} refEl - node before which base element will be inserted\n             * @returns {Node} - inserted element\n             */\n            insertBefore: function (refEl) {\n                return refEl.parentNode.insertBefore(el, refEl);\n            },\n\n            /**\n             * Removes base element from DOM.\n             */\n            remove: function () {\n                el.parentNode.removeChild(el);\n                el = null;\n            },\n\n            /**\n             * Returns true if base element contains given child.\n             * @param {Node|HTMLElement} child\n             * @returns {boolean}\n             */\n            contains: function (child) {\n                return el !== child && el.contains(child);\n            },\n\n            /**\n             * Wraps base element in wrapper element.\n             * @param {HTMLElement} wrapper\n             * @returns {HTMLElement} wrapper element\n             */\n            wrap: function (wrapper) {\n                if (el.parentNode) {\n                    el.parentNode.insertBefore(wrapper, el);\n                }\n\n                wrapper.appendChild(el);\n                return wrapper;\n            },\n\n            /**\n             * Unwraps base element.\n             * @returns {Node[]} - child nodes of unwrapped element.\n             */\n            unwrap: function () {\n                var nodes = Array.prototype.slice.call(el.childNodes),\n                    wrapper;\n\n                nodes.forEach(function (node) {\n                    wrapper = node.parentNode;\n                    dom(node).insertBefore(node.parentNode);\n                    dom(wrapper).remove();\n                });\n\n                return nodes;\n            },\n\n            /**\n             * Returns array of base element parents.\n             * @returns {HTMLElement[]}\n             */\n            parents: function () {\n                var parent, path = [];\n\n                while (!!(parent = el.parentNode)) {\n                    path.push(parent);\n                    el = parent;\n                }\n\n                return path;\n            },\n\n            /**\n             * Normalizes text nodes within base element, ie. merges sibling text nodes and assures that every\n             * element node has only one text node.\n             * It should does the same as standard element.normalize, but IE implements it incorrectly.\n             */\n            normalizeTextNodes: function () {\n                if (!el) {\n                    return;\n                }\n\n                if (el.nodeType === NODE_TYPE.TEXT_NODE) {\n                    while (el.nextSibling && el.nextSibling.nodeType === NODE_TYPE.TEXT_NODE) {\n                        el.nodeValue += el.nextSibling.nodeValue;\n                        el.parentNode.removeChild(el.nextSibling);\n                    }\n                } else {\n                    dom(el.firstChild).normalizeTextNodes();\n                }\n                dom(el.nextSibling).normalizeTextNodes();\n            },\n\n            /**\n             * Returns element background color.\n             * @returns {CSSStyleDeclaration.backgroundColor}\n             */\n            color: function () {\n                return el.style.backgroundColor;\n            },\n\n            /**\n             * Creates dom element from given html string.\n             * @param {string} html\n             * @returns {NodeList}\n             */\n            fromHTML: function (html) {\n                var div = document.createElement('div');\n                div.innerHTML = html;\n                return div.childNodes;\n            },\n\n            /**\n             * Returns first range of the window of base element.\n             * @returns {Range}\n             */\n            getRange: function () {\n                var selection = dom(el).getSelection(),\n                    range;\n\n                if (selection.rangeCount > 0) {\n                    range = selection.getRangeAt(0);\n                }\n\n                return range;\n            },\n\n            /**\n             * Removes all ranges of the window of base element.\n             */\n            removeAllRanges: function () {\n                var selection = dom(el).getSelection();\n                selection.removeAllRanges();\n            },\n\n            /**\n             * Returns selection object of the window of base element.\n             * @returns {Selection}\n             */\n            getSelection: function () {\n                return dom(el).getWindow().getSelection();\n            },\n\n            /**\n             * Returns window of the base element.\n             * @returns {Window}\n             */\n            getWindow: function () {\n                return dom(el).getDocument().defaultView;\n            },\n\n            /**\n             * Returns document of the base element.\n             * @returns {HTMLDocument}\n             */\n            getDocument: function () {\n                // if ownerDocument is null then el is the document itself.\n                return el.ownerDocument || el;\n            }\n\n        };\n    };\n\n    function bindEvents(el, scope) {\n        el.addEventListener('mouseup', scope.highlightHandler.bind(scope));\n        el.addEventListener('touchend', scope.highlightHandler.bind(scope));\n    }\n\n    function unbindEvents(el, scope) {\n        el.removeEventListener('mouseup', scope.highlightHandler.bind(scope));\n        el.removeEventListener('touchend', scope.highlightHandler.bind(scope));\n    }\n\n    /**\n     * Creates TextHighlighter instance and binds to given DOM elements.\n     * @param {HTMLElement} element - DOM element to which highlighted will be applied.\n     * @param {object} [options] - additional options.\n     * @param {string} options.color - highlight color.\n     * @param {string} options.highlightedClass - class added to highlight, 'highlighted' by default.\n     * @param {string} options.contextClass - class added to element to which highlighter is applied,\n     *  'highlighter-context' by default.\n     * @param {function} options.onRemoveHighlight - function called before highlight is removed. Highlight is\n     *  passed as param. Function should return true if highlight should be removed, or false - to prevent removal.\n     * @param {function} options.onBeforeHighlight - function called before highlight is created. Range object is\n     *  passed as param. Function should return true to continue processing, or false - to prevent highlighting.\n     * @param {function} options.onAfterHighlight - function called after highlight is created. Array of created\n     * wrappers is passed as param.\n     * @class TextHighlighter\n     */\n    function TextHighlighter(element, options) {\n        if (!element) {\n            throw 'Missing anchor element';\n        }\n\n        this.el = element;\n        this.options = defaults(options, {\n            color: '#ffff7b',\n            highlightedClass: 'highlighted',\n            contextClass: 'highlighter-context',\n            manual: true,\n            onRemoveHighlight: function () { return true; },\n            onBeforeHighlight: function () { return true; },\n            onAfterHighlight: function () { }\n        });\n\n        dom(this.el).addClass(this.options.contextClass);\n\n        if(!options.manual) {\n            bindEvents(this.el, this);\n        }\n\n    }\n\n    /**\n     * Permanently disables highlighting.\n     * Unbinds events and remove context element class.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.destroy = function () {\n        unbindEvents(this.el, this);\n        dom(this.el).removeClass(this.options.contextClass);\n    };\n\n    TextHighlighter.prototype.highlightHandler = function () {\n        this.doHighlight();\n    };\n\n    /**\n     * Highlights current range.\n     * @param {boolean} keepRange - Don't remove range after highlighting. Default: false.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.doHighlight = function (keepRange) {\n        var range = dom(this.el).getRange(),\n            wrapper,\n            createdHighlights,\n            normalizedHighlights,\n            timestamp;\n\n        if (!range || range.collapsed) {\n            return;\n        }\n\n        if (this.options.onBeforeHighlight(range) === true) {\n            timestamp = +new Date();\n            wrapper = TextHighlighter.createWrapper(this.options);\n            wrapper.setAttribute(TIMESTAMP_ATTR, timestamp);\n\n            createdHighlights = this.highlightRange(range, wrapper);\n            normalizedHighlights = this.normalizeHighlights(createdHighlights);\n\n            this.options.onAfterHighlight(range, normalizedHighlights, timestamp);\n        }\n\n        if (!keepRange) {\n            dom(this.el).removeAllRanges();\n        }\n    };\n\n    /**\n     * Highlights range.\n     * Wraps text of given range object in wrapper element.\n     * @param {Range} range\n     * @param {HTMLElement} wrapper\n     * @returns {Array} - array of created highlights.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.highlightRange = function (range, wrapper) {\n        if (!range || range.collapsed) {\n            return [];\n        }\n\n        var result = refineRangeBoundaries(range),\n            startContainer = result.startContainer,\n            endContainer = result.endContainer,\n            goDeeper = result.goDeeper,\n            done = false,\n            node = startContainer,\n            highlights = [],\n            highlight,\n            wrapperClone,\n            nodeParent;\n\n        do {\n            if (goDeeper && node.nodeType === NODE_TYPE.TEXT_NODE) {\n\n                if (IGNORE_TAGS.indexOf(node.parentNode.tagName) === -1 && node.nodeValue.trim() !== '') {\n                    wrapperClone = wrapper.cloneNode(true);\n                    wrapperClone.setAttribute(DATA_ATTR, true);\n                    nodeParent = node.parentNode;\n\n                    // highlight if a node is inside the el\n                    if (dom(this.el).contains(nodeParent) || nodeParent === this.el) {\n                        highlight = dom(node).wrap(wrapperClone);\n                        highlights.push(highlight);\n                    }\n                }\n\n                goDeeper = false;\n            }\n            if (node === endContainer && !(endContainer.hasChildNodes() && goDeeper)) {\n                done = true;\n            }\n\n            if (node.tagName && IGNORE_TAGS.indexOf(node.tagName) > -1) {\n\n                if (endContainer.parentNode === node) {\n                    done = true;\n                }\n                goDeeper = false;\n            }\n            if (goDeeper && node.hasChildNodes()) {\n                node = node.firstChild;\n            } else if (node.nextSibling) {\n                node = node.nextSibling;\n                goDeeper = true;\n            } else {\n                node = node.parentNode;\n                goDeeper = false;\n            }\n        } while (!done);\n\n        return highlights;\n    };\n\n    /**\n     * Normalizes highlights. Ensures that highlighting is done with use of the smallest possible number of\n     * wrapping HTML elements.\n     * Flattens highlights structure and merges sibling highlights. Normalizes text nodes within highlights.\n     * @param {Array} highlights - highlights to normalize.\n     * @returns {Array} - array of normalized highlights. Order and number of returned highlights may be different than\n     * input highlights.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.normalizeHighlights = function (highlights) {\n        var normalizedHighlights;\n\n        this.flattenNestedHighlights(highlights);\n        this.mergeSiblingHighlights(highlights);\n\n        // omit removed nodes\n        normalizedHighlights = highlights.filter(function (hl) {\n            return hl.parentElement ? hl : null;\n        });\n\n        normalizedHighlights = unique(normalizedHighlights);\n        normalizedHighlights.sort(function (a, b) {\n            return a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft;\n        });\n\n        return normalizedHighlights;\n    };\n\n    /**\n     * Flattens highlights structure.\n     * Note: this method changes input highlights - their order and number after calling this method may change.\n     * @param {Array} highlights - highlights to flatten.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.flattenNestedHighlights = function (highlights) {\n        var again,\n            self = this;\n\n        sortByDepth(highlights, true);\n\n        function flattenOnce() {\n            var again = false;\n\n            highlights.forEach(function (hl, i) {\n                var parent = hl.parentElement,\n                    parentPrev = parent.previousSibling,\n                    parentNext = parent.nextSibling;\n\n                if (self.isHighlight(parent)) {\n\n                    if (!haveSameColor(parent, hl)) {\n\n                        if (!hl.nextSibling) {\n                            dom(hl).insertBefore(parentNext || parent);\n                            again = true;\n                        }\n\n                        if (!hl.previousSibling) {\n                            dom(hl).insertAfter(parentPrev || parent);\n                            again = true;\n                        }\n\n                        if (!parent.hasChildNodes()) {\n                            dom(parent).remove();\n                        }\n\n                    } else {\n                        parent.replaceChild(hl.firstChild, hl);\n                        highlights[i] = parent;\n                        again = true;\n                    }\n\n                }\n\n            });\n\n            return again;\n        }\n\n        do {\n            again = flattenOnce();\n        } while (again);\n    };\n\n    /**\n     * Merges sibling highlights and normalizes descendant text nodes.\n     * Note: this method changes input highlights - their order and number after calling this method may change.\n     * @param highlights\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.mergeSiblingHighlights = function (highlights) {\n        var self = this;\n\n        function shouldMerge(current, node) {\n            return node && node.nodeType === NODE_TYPE.ELEMENT_NODE &&\n                   haveSameColor(current, node) &&\n                   self.isHighlight(node);\n        }\n\n        highlights.forEach(function (highlight) {\n            var prev = highlight.previousSibling,\n                next = highlight.nextSibling;\n\n            if (shouldMerge(highlight, prev)) {\n                dom(highlight).prepend(prev.childNodes);\n                dom(prev).remove();\n            }\n            if (shouldMerge(highlight, next)) {\n                dom(highlight).append(next.childNodes);\n                dom(next).remove();\n            }\n\n            dom(highlight).normalizeTextNodes();\n        });\n    };\n\n    /**\n     * Sets highlighting color.\n     * @param {string} color - valid CSS color.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.setColor = function (color) {\n        this.options.color = color;\n    };\n\n    /**\n     * Returns highlighting color.\n     * @returns {string}\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.getColor = function () {\n        return this.options.color;\n    };\n\n    /**\n     * Removes highlights from element. If element is a highlight itself, it is removed as well.\n     * If no element is given, all highlights all removed.\n     * @param {HTMLElement} [element] - element to remove highlights from\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.removeHighlights = function (element) {\n        var container = element || this.el,\n            highlights = this.getHighlights({ container: container }),\n            self = this;\n\n        function mergeSiblingTextNodes(textNode) {\n            var prev = textNode.previousSibling,\n                next = textNode.nextSibling;\n\n            if (prev && prev.nodeType === NODE_TYPE.TEXT_NODE) {\n                textNode.nodeValue = prev.nodeValue + textNode.nodeValue;\n                dom(prev).remove();\n            }\n            if (next && next.nodeType === NODE_TYPE.TEXT_NODE) {\n                textNode.nodeValue = textNode.nodeValue + next.nodeValue;\n                dom(next).remove();\n            }\n        }\n\n        function removeHighlight(highlight) {\n            var textNodes = dom(highlight).unwrap();\n\n            textNodes.forEach(function (node) {\n                mergeSiblingTextNodes(node);\n            });\n        }\n\n        sortByDepth(highlights, true);\n\n        highlights.forEach(function (hl) {\n            if (self.options.onRemoveHighlight(hl) === true) {\n                removeHighlight(hl);\n            }\n        });\n    };\n\n    /**\n     * Returns highlights from given container.\n     * @param params\n     * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the\n     * highlighter is applied to.\n     * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to\n     * returned results. Default: true.\n     * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added\n     * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp'\n     * property. Default: false.\n     * @returns {Array} - array of highlights.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.getHighlights = function (params) {\n        params = defaults(params, {\n            container: this.el,\n            andSelf: true,\n            grouped: false\n        });\n\n        var nodeList = params.container.querySelectorAll('[' + DATA_ATTR + ']'),\n            highlights = Array.prototype.slice.call(nodeList);\n\n        if (params.andSelf === true && params.container.hasAttribute(DATA_ATTR)) {\n            highlights.push(params.container);\n        }\n\n        if (params.grouped) {\n            highlights = groupHighlights(highlights);\n        }\n\n        return highlights;\n    };\n\n    /**\n     * Returns true if element is a highlight.\n     * All highlights have 'data-highlighted' attribute.\n     * @param el - element to check.\n     * @returns {boolean}\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.isHighlight = function (el) {\n        return el && el.nodeType === NODE_TYPE.ELEMENT_NODE && el.hasAttribute(DATA_ATTR);\n    };\n\n    /**\n     * Serializes all highlights in the element the highlighter is applied to.\n     * @returns {string} - stringified JSON with highlights definition\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.serializeHighlights = function () {\n        var highlights = this.getHighlights(),\n            refEl = this.el,\n            hlDescriptors = [];\n\n        function getElementPath(el, refElement) {\n            var path = [],\n                childNodes;\n\n            do {\n                childNodes = Array.prototype.slice.call(el.parentNode.childNodes);\n                path.unshift(childNodes.indexOf(el));\n                el = el.parentNode;\n            } while (el !== refElement || !el);\n\n            return path;\n        }\n\n        sortByDepth(highlights, false);\n\n        highlights.forEach(function (highlight) {\n            var offset = 0, // Hl offset from previous sibling within parent node.\n                length = highlight.textContent.length,\n                hlPath = getElementPath(highlight, refEl),\n                wrapper = highlight.cloneNode(true);\n\n            wrapper.innerHTML = '';\n            wrapper = wrapper.outerHTML;\n\n            if (highlight.previousSibling && highlight.previousSibling.nodeType === NODE_TYPE.TEXT_NODE) {\n                offset = highlight.previousSibling.length;\n            }\n\n            hlDescriptors.push([\n                wrapper,\n                highlight.textContent,\n                hlPath.join(':'),\n                offset,\n                length\n            ]);\n        });\n\n        return JSON.stringify(hlDescriptors);\n    };\n\n    /**\n     * Deserializes highlights.\n     * @throws exception when can't parse JSON or JSON has invalid structure.\n     * @param {object} json - JSON object with highlights definition.\n     * @returns {Array} - array of deserialized highlights.\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.deserializeHighlights = function (json) {\n        var hlDescriptors,\n            highlights = [],\n            self = this;\n\n        if (!json) {\n            return highlights;\n        }\n\n        try {\n            hlDescriptors = JSON.parse(json);\n        } catch (e) {\n            throw \"Can't parse JSON: \" + e;\n        }\n\n        function deserializationFn(hlDescriptor) {\n            var hl = {\n                    wrapper: hlDescriptor[0],\n                    text: hlDescriptor[1],\n                    path: hlDescriptor[2].split(':'),\n                    offset: hlDescriptor[3],\n                    length: hlDescriptor[4]\n                },\n                elIndex = hl.path.pop(),\n                node = self.el,\n                hlNode,\n                highlight,\n                idx;\n\n            while (!!(idx = hl.path.shift())) {\n                node = node.childNodes[idx];\n            }\n\n            if (node.childNodes[elIndex-1] && node.childNodes[elIndex-1].nodeType === NODE_TYPE.TEXT_NODE) {\n                elIndex -= 1;\n            }\n\n            node = node.childNodes[elIndex];\n            hlNode = node.splitText(hl.offset);\n            hlNode.splitText(hl.length);\n\n            if (hlNode.nextSibling && !hlNode.nextSibling.nodeValue) {\n                dom(hlNode.nextSibling).remove();\n            }\n\n            if (hlNode.previousSibling && !hlNode.previousSibling.nodeValue) {\n                dom(hlNode.previousSibling).remove();\n            }\n\n            highlight = dom(hlNode).wrap(dom().fromHTML(hl.wrapper)[0]);\n            highlights.push(highlight);\n        }\n\n        hlDescriptors.forEach(function (hlDescriptor) {\n            try {\n                deserializationFn(hlDescriptor);\n            } catch (e) {\n                if (console && console.warn) {\n                    console.warn(\"Can't deserialize highlight descriptor. Cause: \" + e);\n                }\n            }\n        });\n\n        return highlights;\n    };\n\n    /**\n     * Finds and highlights given text.\n     * @param {string} text - text to search for\n     * @param {boolean} [caseSensitive] - if set to true, performs case sensitive search (default: true)\n     * @memberof TextHighlighter\n     */\n    TextHighlighter.prototype.find = function (text, caseSensitive) {\n        var wnd = dom(this.el).getWindow(),\n            scrollX = wnd.scrollX,\n            scrollY = wnd.scrollY,\n            caseSens = (typeof caseSensitive === 'undefined' ? true : caseSensitive);\n\n        dom(this.el).removeAllRanges();\n\n        if (wnd.find) {\n            while (wnd.find(text, caseSens)) {\n                this.doHighlight(true);\n            }\n        } else if (wnd.document.body.createTextRange) {\n            var textRange = wnd.document.body.createTextRange();\n            textRange.moveToElementText(this.el);\n            while (textRange.findText(text, 1, caseSens ? 4 : 0)) {\n                if (!dom(this.el).contains(textRange.parentElement()) && textRange.parentElement() !== this.el) {\n                    break;\n                }\n\n                textRange.select();\n                this.doHighlight(true);\n                textRange.collapse(false);\n            }\n        }\n\n        dom(this.el).removeAllRanges();\n        wnd.scrollTo(scrollX, scrollY);\n    };\n\n    /**\n     * Creates wrapper for highlights.\n     * TextHighlighter instance calls this method each time it needs to create highlights and pass options retrieved\n     * in constructor.\n     * @param {object} options - the same object as in TextHighlighter constructor.\n     * @returns {HTMLElement}\n     * @memberof TextHighlighter\n     * @static\n     */\n    TextHighlighter.createWrapper = function (options) {\n        var span = document.createElement('span');\n        span.style.backgroundColor = options.color;\n        span.className = options.highlightedClass;\n        return span;\n    };\n\n    global.TextHighlighter = TextHighlighter;\n})(window);\n\n\n//# sourceURL=webpack:///./lib/TextHighlighter.js?");

/***/ }),

/***/ "./web/js/KeyEvents.js":
/*!*****************************!*\
  !*** ./web/js/KeyEvents.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.KeyEvents = class {\n\n    /**\n     * Return true if the 'meta' keys are active. \n     */\n    static isKeyMetaActive(event) {\n        if (KeyEvents.isMacOS()) {\n            return event.altKey && event.metaKey;\n        } else {\n            return event.ctrlKey && event.altKey;\n        }\n    }\n\n    static isMacOS() {\n        return navigator.platform === \"MacIntel\";\n    }\n\n};\n\n//# sourceURL=webpack:///./web/js/KeyEvents.js?");

/***/ }),

/***/ "./web/js/PagemarkCoverageEventListener.js":
/*!*************************************************!*\
  !*** ./web/js/PagemarkCoverageEventListener.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//import $ from 'jquery';\n\nconsole.log(\"FIXME6 module.exports\", module.exports);\n\nconst {Delegator, Styles, Elements, OffsetCalculator} = __webpack_require__(/*! ./utils.js */ \"./web/js/utils.js\");\nconst {KeyEvents} = __webpack_require__(/*! ./KeyEvents.js */ \"./web/js/KeyEvents.js\");\n\nmodule.exports.PagemarkCoverageEventListener = class {\n\n    constructor(controller) {\n        this.controller = controller;\n        this.keyActivated = false;\n    }\n\n    /**\n     * Track that we've selected 'e' on the keyboard,\n     */\n    keyListener(event) {\n\n        console.log(event);\n\n        if(!event) {\n            throw new Error(\"no event\");\n        }\n\n        // on MacOS t needs to be Alt + Meta. Control is already bound.\n        if (KeyEvents.isKeyMetaActive(event)) {\n            console.log(\"FIXME: active now\");\n            this.keyActivated = true;\n        } else {\n\n            console.log(\"FIXME: INactive now\");\n            this.keyActivated = false;\n        }\n\n    }\n\n    mouseListener(event) {\n\n        if(!event) {\n            throw new Error(\"no event\");\n        }\n\n        if(!this.keyActivated) {\n            return;\n        }\n\n        this.onActivated(event);\n\n    }\n\n    // https://stackoverflow.com/questions/3234256/find-mouse-position-relative-to-element\n    onActivated(event) {\n\n        // FIXME: we're closer now.. but we have to factor in some sort of static offet.\n\n        let pageElement = Elements.untilRoot(event.target, \".page\");\n\n        if(! pageElement) {\n            console.log(\"Not within a pageElement\");\n            return;\n        }\n\n        var textLayerElement = pageElement.querySelector(\".textLayer\");\n\n        if(!textLayerElement) {\n            console.error(\"No text layer\");\n            return;\n        }\n\n        let viewport = document.getElementById(\"viewerContainer\");\n\n        let pageOffset = OffsetCalculator.calculate(textLayerElement, viewport.parentElement);\n\n        // FIXME: this is lame.. this is for the border.\n        pageOffset.top += 9;\n\n        // manually adjust the offsets with correct jquery data.\n        pageOffset.height = $(textLayerElement).height();\n        pageOffset.bottom = pageOffset.top + pageOffset.height;\n\n        let mouseTop = event.pageY + viewport.scrollTop;\n\n        if(mouseTop >= pageOffset.top && mouseTop <= pageOffset.bottom) {\n\n            // make sure the current mouse position is within a page.\n\n            let mousePageY = mouseTop - pageOffset.top;\n\n            let percentage = (mousePageY / pageOffset.height) * 100;\n\n            console.log(\"percentage: \", percentage);\n\n            let pageNum = this.controller.getPageNum(pageElement);\n            this.controller.erasePagemark(pageNum);\n            this.controller.createPagemark(pageNum, {percentage});\n\n        } else {\n            console.log(\"Mouse click was outside of page.\")\n        }\n\n    }\n\n    startListening() {\n        document.addEventListener(\"keyup\", this.keyListener.bind(this));\n        document.addEventListener(\"keydown\", this.keyListener.bind(this));\n        document.addEventListener(\"click\", this.mouseListener.bind(this));\n    }\n\n};\n\n\n//# sourceURL=webpack:///./web/js/PagemarkCoverageEventListener.js?");

/***/ }),

/***/ "./web/js/TextHighlightView.js":
/*!*************************************!*\
  !*** ./web/js/TextHighlightView.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("console.log(\"FIXME4 module.exports\", module.exports);\n\n\nmodule.exports.TextHighlightView = class {\n\n    constructor(model) {\n        this.model = mode;\n\n        this.model.registerListenerForDocumentLoaded(this.onDocumentLoaded.bind(this));\n\n    }\n\n    onDocumentLoaded() {\n\n        console.log(\"TextHighlightView.onDocumentLoaded\");\n\n        // register existing annotations\n\n        // var pagemarkRendererDelegates = [\n        //     new MainPagemarkRenderer(this),\n        //     new ThumbnailPagemarkRenderer(this)\n        // ];\n        //\n        // this.pagemarkRenderer = new CompositePagemarkRenderer(this, pagemarkRendererDelegates);\n        // this.pagemarkRenderer.setup();\n        //\n        // this.updateProgress();\n\n    }\n\n    onTextHighlightCreated(textHighlight) {\n        console.log(\"TextHighlightView.onTextHighlightCreated\");\n\n    }\n\n}\n\n\n//# sourceURL=webpack:///./web/js/TextHighlightView.js?");

/***/ }),

/***/ "./web/js/controller/Controller.js":
/*!*****************************************!*\
  !*** ./web/js/controller/Controller.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//import $ from 'jquery';\nconsole.log(\"FIXME module.exports\", module.exports);\n\n\nconst {TextHighlightController} = __webpack_require__(/*! ../text-highlights.js */ \"./web/js/text-highlights.js\");\nconst {PagemarkCoverageEventListener} = __webpack_require__(/*! ../PagemarkCoverageEventListener.js */ \"./web/js/PagemarkCoverageEventListener.js\");\nconst {KeyEvents} = __webpack_require__(/*! ../KeyEvents.js */ \"./web/js/KeyEvents.js\");\nconst {polar} = __webpack_require__(/*! ../polar.js */ \"./web/js/polar.js\");\n\nmodule.exports.Controller = class {\n\n    constructor(datastore, model) {\n        this.datastore = datastore;\n        this.model = model;\n        this.docMeta = null;\n    }\n\n    /**\n     * Called when a new document has been loaded.\n     */\n    onDocumentLoaded(fingerprint, nrPages, currentlySelectedPageNum) {\n\n        this.docMetaPromise = this.model.documentLoaded(fingerprint, nrPages, currentlySelectedPageNum);\n\n    }\n\n    /**\n     * Mark the given page number as read.\n     */\n    createPagemark(pageNum, options) {\n        console.log(\"Controller sees pagemark created: \" + pageNum);\n        this.model.createPagemark(pageNum, options);\n    }\n\n    erasePagemarks(pageNum, options) {\n        console.log(\"Controller sees pagemarks erased: \" + pageNum);\n        this.model.erasePagemark(pageNum, options);\n    }\n\n    /**\n     * Mark the given page number as read.\n     */\n    erasePagemark(num) {\n        console.log(\"Controller sees pagemark erased: \" + num);\n        this.model.erasePagemark(num);\n    }\n\n    getCurrentPageElement() {\n\n    }\n\n};\n\n\n//# sourceURL=webpack:///./web/js/controller/Controller.js?");

/***/ }),

/***/ "./web/js/controller/WebController.js":
/*!********************************************!*\
  !*** ./web/js/controller/WebController.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst {TextHighlightController} = __webpack_require__(/*! ../text-highlights.js */ \"./web/js/text-highlights.js\");\nconst {PagemarkCoverageEventListener} = __webpack_require__(/*! ../PagemarkCoverageEventListener.js */ \"./web/js/PagemarkCoverageEventListener.js\");\nconst {KeyEvents} = __webpack_require__(/*! ../KeyEvents.js */ \"./web/js/KeyEvents.js\");\nconst {Controller} = __webpack_require__(/*! ./Controller.js */ \"./web/js/controller/Controller.js\");\n\nmodule.exports.WebController = class extends Controller {\n\n    constructor(datastore, model) {\n        super(datastore, model);\n\n        this.datastore = datastore;\n\n        /**\n         * The document fingerprint that we have loaded to detect when the\n         * documents have changed.  Note that this isn't a secure fingerprint\n         * so we might want to change it in the future.\n         *\n         * @type string\n         */\n        this.docFingerprint = null;\n\n    }\n\n    startListeners() {\n        this.listenForDocumentLoad();\n        this.listenForKeyBindings();\n\n        console.log(\"Controller listeners registered.\");\n    }\n\n    listenForDocumentLoad() {\n\n        let container = document.getElementById('viewerContainer');\n\n        container.addEventListener('pagesinit', this.detectDocumentLoadedEventListener.bind(this));\n        container.addEventListener('updateviewarea', this.detectDocumentLoadedEventListener.bind(this));\n\n    }\n\n    detectDocumentLoadedEventListener(event) {\n\n        if (window.PDFViewerApplication &&\n            window.PDFViewerApplication.pdfDocument &&\n            window.PDFViewerApplication.pdfDocument.pdfInfo &&\n            window.PDFViewerApplication.pdfDocument.pdfInfo.fingerprint != this.docFingerprint) {\n\n            console.log(\"controller: New document loaded!\")\n\n            let newDocumentFingerprint = window.PDFViewerApplication.pdfDocument.pdfInfo.fingerprint;\n            let nrPages = window.PDFViewerApplication.pagesCount;\n            var currentPageNumber = window.PDFViewerApplication.pdfViewer.currentPageNumber;\n\n            var pageElement = event.target.parentElement;\n            var pageNum = this.getPageNum(pageElement);\n\n            this.onNewDocumentFingerprint(newDocumentFingerprint, nrPages, currentPageNumber);\n\n        }\n\n    }\n\n    onNewDocumentFingerprint(newDocumentFingerprint, nrPages, currentPageNumber) {\n\n        console.log(`Detected new document fingerprint (fingerprint=${newDocumentFingerprint}, nrPages=${nrPages}, currentPageNumber=${currentPageNumber})`);\n\n        this.docFingerprint = newDocumentFingerprint;\n\n        this.onDocumentLoaded(newDocumentFingerprint, nrPages, currentPageNumber);\n\n    }\n\n    traceEventOnPage(event, eventName) {\n        var pageElement = event.target.parentElement;\n        var pageNum = this.getPageNum(pageElement);\n\n        console.log(`Found event ${eventName} on page number ${pageNum}`);\n\n    }\n\n    onViewerElementInserted() {\n\n        // FIXME: try to use window.PDFViewerApplication.eventBus with:\n        //\n        // documentload, pagerendered, textlayerrendered, pagechange, and pagesinit...\n\n        if (window.PDFViewerApplication &&\n            window.PDFViewerApplication.pdfDocument &&\n            window.PDFViewerApplication.pdfDocument.pdfInfo &&\n            window.PDFViewerApplication.pdfDocument.pdfInfo.fingerprint != this.docFingerprint) {\n\n            let newDocumentFingerprint = window.PDFViewerApplication.pdfDocument.pdfInfo.fingerprint;\n            let nrPages = window.PDFViewerApplication.pagesCount;\n\n            var pages = document.querySelectorAll(\"#viewer .page\");\n\n            // fIXME:: I need to find the current selected page\n            var currentPageNumber = window.PDFViewerApplication.pdfViewer.currentPageNumber;\n\n            if (pages.length === nrPages) {\n                this.onNewDocumentFingerprint(newDocumentFingerprint, nrPages, currentPageNumber);\n            }\n\n        }\n\n    }\n\n    getCurrentPageElement() {\n\n        // TODO: It is probably easier to use pdf.pageNum but I'm not sure if this\n        // is actively updated or not.\n        let pages = document.querySelectorAll(\".page\");\n\n        let result = { element: null, visibility: 0};\n\n        pages.forEach(function (page) {\n            let visibility = this.calculateVisibilityForDiv(page);\n\n            if ( visibility > result.visibility) {\n                result.element = page;\n                result.visibility = visibility;\n            }\n\n        }.bind(this));\n\n        return result.element;\n\n    }\n\n    calculateVisibilityForDiv(div) {\n\n        if(div == null)\n            throw Error(\"Not given a div\");\n\n        var windowHeight = $(window).height(),\n            docScroll = $(document).scrollTop(),\n            divPosition = $(div).offset().top,\n            divHeight = $(div).height();\n\n        var hiddenBefore = docScroll - divPosition,\n            hiddenAfter = (divPosition + divHeight) - (docScroll + windowHeight);\n\n        if ((docScroll > divPosition + divHeight) || (divPosition > docScroll + windowHeight)) {\n            return 0;\n        } else {\n            var result = 100;\n\n            if (hiddenBefore > 0) {\n                result -= (hiddenBefore * 100) / divHeight;\n            }\n\n            if (hiddenAfter > 0) {\n                result -= (hiddenAfter * 100) / divHeight;\n            }\n\n            return result;\n        }\n\n    }\n\n    getPageNum(pageElement) {\n        var pageElement = this.getCurrentPageElement();\n        let dataPageNum = pageElement.getAttribute(\"data-page-number\");\n        return parseInt(dataPageNum);\n    }\n\n    // FIXME: remake this binding to CreatePagemarkEntirePage\n    keyBindingPagemarkEntirePage(event) {\n\n        console.log(\"Marking entire page as read.\");\n\n        var pageElement = this.getCurrentPageElement();\n        var pageNum = this.getPageNum(pageElement);\n\n        this.erasePagemarks(pageNum);\n        this.createPagemark(pageNum);\n\n    }\n\n    keyBindingPagemarkUpToMouse(event) {\n        console.log(\"Marking page as read up to mouse point\");\n    }\n\n    keyBindingErasePagemark(event) {\n        console.log(\"Erasing pagemark.\");\n        var pageElement = this.getCurrentPageElement();\n        let pageNum = this.getPageNum(pageElement);\n        this.erasePagemark(pageNum);\n    }\n\n    keyBindingListener(event) {\n\n        if (KeyEvents.isKeyMetaActive(event)) {\n\n            const eCode = 69;\n\n            const mCode = 77;\n            const nCode = 78;\n\n            // used for MacOS where it generates an 'N' for some reason.\n            const NCode = 192;\n\n            switch (event.which) {\n\n                case eCode:\n                    this.keyBindingErasePagemark(event);\n                    break;\n\n                case mCode:\n                    // FIME this is no longer used here.\n                    this.keyBindingPagemarkUpToMouse(event);\n                    break;\n\n                case nCode:\n                    this.keyBindingPagemarkEntirePage(event);\n                    break;\n\n                case NCode:\n                    this.keyBindingPagemarkEntirePage(event);\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n    }\n\n    listenForKeyBindings() {\n\n        if(polar.state.listenForKeyBindings) {\n            return;\n        }\n\n        document.addEventListener(\"keydown\", this.keyBindingListener.bind(this));\n\n        polar.state.listenForKeyBindings = true;\n\n        console.log(\"Key bindings registered\");\n\n        TextHighlightController.create().listenForKeyBindings();\n\n        new PagemarkCoverageEventListener(this).startListening();\n\n    }\n\n};\n\n\n\n//# sourceURL=webpack:///./web/js/controller/WebController.js?");

/***/ }),

/***/ "./web/js/datastore/Datastore.js":
/*!***************************************!*\
  !*** ./web/js/datastore/Datastore.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// A datastore that supports ledgers and checkpoints.\nmodule.exports.Datastore = class {\n\n    /**\n     * Init the datastore, potentially reading files of disk, the network, etc.\n     */\n    async init() {\n\n    }\n\n    /**\n     * Get the DocMeta object we currently in the datastore for this given\n     * fingerprint or null if it does not exist.\n     */\n    async getDocMeta(fingerprint) {\n\n    }\n\n    /**\n     * Write the datastore to disk.\n     */\n    async sync(fingerprint, docMeta) {\n\n    }\n\n};\n\n//# sourceURL=webpack:///./web/js/datastore/Datastore.js?");

/***/ }),

/***/ "./web/js/datastore/MemoryDatastore.js":
/*!*********************************************!*\
  !*** ./web/js/datastore/MemoryDatastore.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {MetadataSerializer, DocMeta} = __webpack_require__(/*! ../metadata/metadata.js */ \"./web/js/metadata/metadata.js\");\nconst {Datastore} = __webpack_require__(/*! ./Datastore.js */ \"./web/js/datastore/Datastore.js\");\n\n/**\n * Datastore just in memory with no on disk persistence.\n */\nmodule.exports.MemoryDatastore = class extends Datastore {\n\n    constructor() {\n\n        super();\n        /**\n         *\n         * @type map<string,DocMeta>\n         */\n        this.docMetas = {}\n\n    }\n\n    async init() {\n\n    }\n\n    /**\n     * Get the DocMeta object we currently in the datastore for this given\n     * fingerprint or null if it does not exist.\n     */\n    async getDocMeta(fingerprint) {\n\n        var nrDocs = Object.keys(this.docMetas).length;\n\n        console.log(`Fetching document from datastore with fingerprint ${fingerprint} of ${nrDocs} docs.`)\n\n        return this.docMetas[fingerprint];\n    }\n\n    /**\n     * Write the datastore to disk.\n     */\n    async sync(fingerprint, docMeta) {\n\n        // create a copy of the docMeta so that the version we store is NOT\n        // the same version we have in memory.\n        docMeta = MetadataSerializer.deserialize(new DocMeta(), MetadataSerializer.serialize(docMeta));\n        this.docMetas[fingerprint] = docMeta;\n    }\n\n};\n\n\n//# sourceURL=webpack:///./web/js/datastore/MemoryDatastore.js?");

/***/ }),

/***/ "./web/js/entry.js":
/*!*************************!*\
  !*** ./web/js/entry.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//const {$} = require('jquery');\nconsole.log(\"FIXME module.exports\", module.exports);\nconst {DocMeta} = __webpack_require__(/*! ./metadata/metadata.js */ \"./web/js/metadata/metadata.js\");\nconst {Controller} = __webpack_require__(/*! ./controller/Controller.js */ \"./web/js/controller/Controller.js\");\nconst {WebController} = __webpack_require__(/*! ./controller/WebController.js */ \"./web/js/controller/WebController.js\");\nconst {WebView} = __webpack_require__(/*! ./view/WebView.js */ \"./web/js/view/WebView.js\");\nconst {TextHighlightController} = __webpack_require__(/*! ./text-highlights.js */ \"./web/js/text-highlights.js\");\n\nconst {SystemClock} = __webpack_require__(/*! ./time/SystemClock.js */ \"./web/js/time/SystemClock.js\");\nconst {MemoryDatastore} = __webpack_require__(/*! ./datastore/MemoryDatastore.js */ \"./web/js/datastore/MemoryDatastore.js\");\nconst {Model} = __webpack_require__(/*! ./model.js */ \"./web/js/model.js\");\n\n\n/// /\n//\n// // /**\n// //  * Inject our customization around PDFs including custom CSS and custom scripts.\n// //  */\n// // async function injectAllScripts() {\n// //\n// //     // inject our customizations manually so that we can just depend on the\n// //     // stock pdf.js viewer.html application.\n// //\n// //     // TODO: make this into an if / then if we're running in a renderer process.\n// //     // if(isElectron()) {\n// //     //     window.$ = window.jQuery = await require('/node_modules/jquery/dist/jquery.min.js');\n// //     // } else {\n// //     await injectScript('/node_modules/jquery/dist/jquery.min.js', 'module');\n// //     window.$ = window.jQuery;\n// //     // }\n// //\n// //     // TODO: use a Promise.all() on all of these to await them as a batch.\n// //     // It's not going to make a massive performance difference though since we\n// //     // are loading locally.\n// //\n// //     await injectScript('/web/js/utils.js', 'module');\n// //     await injectScript('/web/js/polar.js');\n// //     //injectScript('/web/js/annotations.js');\n// //     await injectScript('/web/js/metadata.js');\n// //     await injectScript('/web/js/model.js');\n// //     await injectScript('/web/js/view.js', 'module');\n// //     await injectScript('/web/js/controller.js', 'module');\n// //     await injectScript('/web/js/clock.js');\n// //     await injectScript('/web/js/optional.js');\n// //     await injectScript('/web/js/datastore/datastore.js');\n// //     await injectScript('/web/js/text-highlights.js', 'module');\n// //     await injectScript('/lib/TextHighlighter.js');\n// //\n// // }\n\nfunction launchDev() {\n\n    console.log(\"Launching in dev mode.\");\n\n    var clock = new SystemClock();\n    var datastore = new MemoryDatastore();\n    var model = new Model(datastore, clock);\n    var controller = new WebController(datastore, model);\n    var view = new WebView(model);\n\n    // create some fake documents for our example PDFs\n    var fingerprint = \"110dd61fd57444010b1ab5ff38782f0f\";\n\n    let docMeta = DocMeta.createWithinInitialPagemarks(fingerprint, 14);\n    DocMeta.addPagemarks(docMeta, {nrPages: 1, offsetPage: 4, percentage: 50})\n    datastore.sync(fingerprint, docMeta);\n\n    view.init();\n\n    start(datastore, controller, \"dev\");\n\n}\n//\n// async function launchProd() {\n//\n//     console.log(\"Launching in prod mode.\");\n//\n//     const remote = require('electron').remote;\n//     var datastore = remote.getGlobal(\"diskDatastore\" );\n//\n//     var clock = new SystemClock();\n//     var model = new Model(datastore, clock);\n//     var controller = new WebController(datastore, model);\n//     var view = new WebView(model);\n//     view.init();\n//\n//     start(datastore, controller, \"prod\");\n//\n// }\n//\nasync function start(datastore, controller, mode) {\n\n    await datastore.init();\n\n    controller.startListeners();\n    console.log(\"Controller started in mode: \" + mode);\n\n}\n\nfunction launch(launcherFunction) {\n\n    if (document.readyState === \"complete\" || document.readyState === \"loaded\" || document.readyState === \"interactive\") {\n        console.log(\"Already completed loading.\");\n        launcherFunction();\n    } else {\n        console.log(\"Waiting for DOM content to load\");\n        document.addEventListener('DOMContentLoaded', launcherFunction, true);\n    }\n\n}\n\n/**\n * Init the page by loading all scripts, etc.\n */\nasync function init() {\n\n    // await injectAllScripts();\n\n    if(isElectron()) {\n        launch(launchProd);\n    } else {\n        launch(launchDev);\n    }\n\n}\n\nfunction isElectron() {\n    var userAgent = navigator.userAgent.toLowerCase();\n    return userAgent.indexOf(' electron/') !== -1;\n}\n\ninit();\n\n\n//# sourceURL=webpack:///./web/js/entry.js?");

/***/ }),

/***/ "./web/js/metadata/metadata.js":
/*!*************************************!*\
  !*** ./web/js/metadata/metadata.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst { forDict } = __webpack_require__(/*! ../utils.js */ \"./web/js/utils.js\");\n\n/*\n\n general metadata structure\n\n doc\n    title: string\n    path: string\n    hashcode: string\n\n    pages: PAGE*\n\n PAGE:\n    id: string\n    annotations: ANNOTATION*\n\n # FIXME: I think we need to have separate types for each annotation.  So we\n # would have a NOTE, a HIGHLIGHT, AREA_HIGHLIGHT, TEXT, COMMENT, STRIKETHROUGH)\n #\n # FIXME: each annotation should be able to have OTHER metadata which is like a\n # 'comment' but a 'comment' at a high level\n\n ANNOTATION:\n    box: BOX\n    created: timestamp - ISO8601 that the annotation was created\n    creator: AUTHOR\n\n ANNOTATION:\n    box: BOX\n    created: timestamp - ISO8601 that the annotation was created\n    last_updated: timestamp - used if the annotation is moved or if the note was updated.\n    creator: AUTHOR\n\n ANNOTATION_WITH_NOTE extends ANNOTATION:\n    note:\n    emotion:\n\n EMOTION\n    INFO\n    WARNING\n    FATAL\n\n HIGHLIGHT\n    priority: (1,2,3,4)  - priorities give us different colors ... but these\n                           should probably be like primary, secondary, tertiary\n                           FIXME: an area highlight should have these too.\n\n PAGEMARK extends ANNOTATION_WITH_NOTE\n    coverage: float 0.0 -> 1.0\n\n Bookmark extends ANNOTATION_WITH_NOTE\n\n AUTHOR:\n    id\n    name\n    email\n    link\n\n BOX:\n    x: int - X position on the page\n    y\n    width\n    height\n\n NOTE:\n    data: string\n    format: MARKDOWN|HTML\n\n\n */\n\n\nfunction createDocMeta(path) {\n\n    return { title: null,\n             path: null,\n             hashcode: null,\n             pagemarks: {} };\n\n}\n\n\n/**\n * Basic serialized object pattern. Take a closure as an argument to init,\n * and then assign the fields.  Then setup and validate that we have our\n * required data structures.\n */\nclass SerializedObject {\n\n    constructor(val) {\n        // noop\n    }\n\n    init(val) {\n\n        if(arguments.length > 1) {\n            throw new Error(\"Too many arguments\");\n        }\n\n        if(typeof val === \"object\") {\n\n            Object.assign(this, val);\n            this.setup();\n            this.validate();\n\n        }\n\n    }\n\n    setup() {\n\n    }\n\n    validate() {\n\n    }\n\n    validateMemberExists(name) {\n\n        if(!this[name]) {\n            throw new Error(`Member field '${name}' missing.`);\n        }\n\n    }\n\n    /**\n     * Validate that the member is defined and that it has the given type.\n     *\n     * These are instance types compared via instanceof\n     *\n     * @param name The name of the member.\n     * @param instanceType The instance type we expect\n     */\n    validateMemberInstanceOf(name, instance) {\n\n        this.validateMemberExists(name);\n\n        if( ! this[name] instanceof instance) {\n            throw new Error(`Member field '${name}' is not a instance of ${instance}`);\n        }\n    }\n\n    /**\n     * Validate that the given member exists and it is a typeof of 'type'\n     *\n     * The types in this case are primitive types compared with typeof\n     *\n     * @param name The name of the member.\n     * @param instanceType The instance type we expect\n     */\n    validateMemberTypeOf(name, type) {\n\n        this.validateMemberExists(name);\n\n        if( ! typeof this[name] === type) {\n            throw new Error(`Member field '${name}' is not a type of ${type}`);\n        }\n\n    }\n\n    validateMember(member) {\n\n        if (member.instance) {\n            this.validateMemberInstanceOf(member.name, member.instance);\n        } else if(member.type) {\n            this.validateMemberTypeOf(member.name, member.type);\n        } else {\n            throw new Error(\"Unable to handle member: \", member);\n        }\n    }\n\n    validateMembers(members) {\n\n        // TODO: needs testing.\n\n        var caller = this;\n\n        members.forEach(this.validateMember.bind(this));\n\n    }\n\n}\n\nmodule.exports.DocMetaDescriber = class {\n\n    static describe(docMeta) {\n\n        var nrPagemarks = 0;\n\n        forDict(docMeta.pageMetas, function (key, pageMeta) {\n            forDict(pageMeta.pagemarks, function (column, pagemark) {\n                ++nrPagemarks;\n            }.bind(this));\n\n        }.bind(this));\n\n\n        return `PDF with ${docMeta.docInfo.nrPages} pages and ${nrPagemarks} pagemarks.`\n    }\n\n}\n\n/**\n * Root metadata for a document including page metadata, and metadata for\n * the specific document.\n */\nmodule.exports.DocMeta = class extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The DocInfo which includes information like title, nrPages, etc.\n         * @type DocInfo\n         */\n        this.docInfo = null;\n\n        /**\n         * A sparse dictionary of page number to page metadata.\n         *\n         * @type map<int,PageMeta>\n         */\n        this.pageMetas = {}\n\n        /**\n         * The version of this DocMeta version.\n         */\n        this.version = 1;\n\n        this.init(val);\n\n    }\n\n    getPageMeta(num) {\n\n        let pageMeta = this.pageMetas[num];\n\n        if (!pageMeta) {\n            throw new Error(\"No pageMeta for page: \" + num);\n        }\n\n        return pageMeta;\n\n    }\n\n    validate() {\n\n        this.validateMembers([\n            {name: 'docInfo', instance: DocInfo},\n            {name: 'pageMetas', type: \"object\"},\n            {name: 'version', type: \"number\"}\n        ]);\n    }\n\n    /**\n     * Create the basic DocInfo structure that we can use with required / basic\n     * field structure.\n     * @param nrPages The number of pages in this document.\n     * @returns {DocMeta}\n     */\n    static create(fingerprint, nrPages) {\n\n        let docInfo = new DocInfo({fingerprint, nrPages});\n\n        let pageMetas = {};\n\n        for(let idx = 1; idx <= nrPages; ++idx) {\n            let pageInfo = new PageInfo({num: idx});\n            let pageMeta = new PageMeta({pageInfo: pageInfo});\n            pageMetas[idx] = pageMeta;\n        }\n\n        return new DocMeta({docInfo, pageMetas});\n\n    }\n\n    /**\n     * Create a DocMeta object but place initial pagemarks on it. This is useful\n     * for testing.\n     */\n    static createWithinInitialPagemarks(fingerprint, nrPages) {\n\n        var result = this.create(fingerprint, nrPages);\n\n        let maxPages = 3;\n        for(var pageNum = 1; pageNum <= Math.min(nrPages, maxPages); ++pageNum ) {\n\n            let pagemark = new Pagemark({\n                // TODO: this shouldn't have a hard wired date here but we don't\n                // have a dependency injector yet.\n                created: new Date(),\n                type: PagemarkType.SINGLE_COLUMN,\n                percentage: 100,\n                column: 0\n            });\n\n            let pageMeta = result.getPageMeta(pageNum);\n\n            // set the pagemark that we just created.\n            pageMeta.pagemarks[pagemark.column] = pagemark;\n\n        }\n\n        return result;\n\n    }\n\n    /**\n     */\n    static addPagemarks(docMeta, options) {\n\n        if (!options) {\n            options = {};\n        }\n\n        if (!options.nrPages) {\n            options.nrPages = 3;\n        }\n\n        if (!options.offsetPage) {\n            // the starting page\n            options.offsetPage = 1;\n        }\n\n        if (!options.percentage) {\n            // the percentage value from 0-100\n            options.percentage = 100;\n        }\n\n        var maxPageNum = Math.min(options.offsetPage + options.nrPages -1, docMeta.docInfo.nrPages);\n\n        for(var pageNum = options.offsetPage; pageNum <= maxPageNum; ++pageNum ) {\n\n            let pagemark = new Pagemark({\n                // TODO: this shouldn't have a hard wired date here but we don't\n                // have a dependency injector yet.\n                created: new Date(),\n                type: PagemarkType.SINGLE_COLUMN,\n                percentage: options.percentage,\n                column: 0\n            });\n\n            let pageMeta = docMeta.getPageMeta(pageNum);\n\n            // set the pagemark that we just created.\n            pageMeta.pagemarks[pagemark.column] = pagemark;\n\n        }\n\n\n    }\n\n};\n\n/**\n * Lightweight metadata about a document. We do not include full page metadata\n * with this object which makes it lightweight to pass around.\n */\nclass DocInfo extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The title for the document.\n         * @type {null}\n         */\n        this.title = null;\n\n        /**\n         * The network URL for the document where we originally fetched it.\n         * @type string\n         */\n        this.url = null;\n\n        /**\n         * The number of pages in this document.\n         *\n         * @type number\n         */\n        this.nrPages = null;\n\n        /**\n         * A fingerprint for the document created from PDF.js\n         * @type string\n         */\n        this.fingerprint = null;\n\n        this.init(val);\n\n    }\n\n    validate() {\n        this.validateMembers([\n            {name: 'nrPages', type: \"number\"},\n            {name: 'fingerprint', type: \"string\"}\n        ]);\n    }\n\n\n}\n\nmodule.exports.PageMeta = class extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The pageInfo for this page.\n         */\n        this.pageInfo = null;\n\n        /**\n         * The index of page number to pagemark which stores the data we need\n         * for keeping track of pagemarks.  The index is the pagemark column.\n         *\n         * @type map<int,pagemark>.\n         */\n        this.pagemarks = {};\n\n        this.init(val);\n\n    }\n\n    validate() {\n        this.validateMembers([\n            {name: 'pageInfo', instance: PageInfo}\n        ]);\n    }\n\n}\n\nclass PageInfo extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The page number of this page.\n         *\n         * @type number.\n         */\n        this.num = null;\n\n        this.init(val);\n\n    }\n\n    validate() {\n        this.validateMembers([\n           {name: 'num', type: \"number\"}\n        ]);\n    }\n\n}\n\n/**\n *\n * Basic ISO8601 date and time format.\n */\nclass ISODateTime {\n\n    constructor(value) {\n\n        /**\n         * The Date object representing this time.\n         */\n        this.date = null;\n\n        if (typeof value === \"string\") {\n            this.date = Date.parse(value);\n        } else if(value instanceof Date) {\n            this.date = value;\n        } else {\n            throw new Error(\"Invalid type: \" + typeof value);\n        }\n\n    }\n\n    toDate() {\n        return this.date;\n    }\n\n    toJSON() {\n        return this.date.toISOString();\n    }\n\n    toString() {\n        return this.date.toISOString();\n    }\n\n}\n\nclass Symbol {\n\n    constructor(name) {\n        this.name = name;\n    }\n\n\n    toJSON() {\n        return this.name;\n    }\n\n}\n\n// this is I think a better pattern for typesafe enum:\n// http://2ality.com/2016/01/enumify.html\nconst TextType = {\n    MARKDOWN: new Symbol(\"MARKDOWN\"),\n    HTML: new Symbol(\"HTML\")\n}\n\nclass Text extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n        /**\n         * The actual body of this text.\n         *\n         * @type {string}\n         */\n        this.body = \"\";\n\n        /**\n         * The type of this text.  Defaults to MARKDOWN.\n         * @type {number}\n         */\n        this.type = TextType.MARKDOWN;\n\n        this.init(val);\n\n    }\n\n}\n\nclass Author extends SerializedObject {\n\n    constructor(val) {\n        super(val);\n\n        /**\n         * The name of this author.\n         * @type string\n         */\n        this.name = null;\n\n    }\n\n}\n\n/**\n * Private note describing this object.  Meant to last a long time.\n */\nclass Note extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The text of this note.\n         *\n         * @type {Text}\n         */\n        this.text = null;\n\n        /**\n         * @type ISODateTime\n         */\n        this.created = null;\n\n        /**\n         *\n         * @type Author\n         */\n        this.author = null;\n\n        this.init(val);\n\n    };\n\n    setup() {\n\n        if(!this.text) {\n            this.text = \"\";\n        }\n\n    }\n\n    validate() {\n\n        if(!this.created) {\n            throw new Error(\"The field `created` is required.\");\n        }\n\n    }\n\n}\n\n/**\n * Basically just like a note but it's a comment in a discussion stream.\n */\nclass Comment extends Note {\n\n    constructor() {\n        super(val);\n    }\n\n}\n\nclass BaseHighlight extends SerializedObject {\n\n    constructor(val) {\n        super(val);\n\n        /**\n         * The rectangles where we need to place content for this highlights.\n         * @type {{}}\n         */\n        this.rects = {};\n\n        // this.linesOfText = {};\n        //\n        // this.text\n\n        /**\n         * Optional thumbnail for this highlight.\n         * @type {null}\n         */\n        this.thumbnail = null;\n\n    }\n\n}\n\nclass TextRect extends SerializedObject {\n\n    constructor(val) {\n        super(val);\n\n        // the actual text in this rect.\n        this.text = null;\n\n        // A rect area that the user has selected text.\n        this.rect = null;\n\n    }\n\n}\n\nclass TextHighlight extends BaseHighlight {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * A raw array-like object of text from the regions that the user\n         * has highlighted in the UI. In PDF and pdf.js there isn't really\n         * the concept of flowing text so we try to show the user the text\n         * in the specific regions they selected.\n         *\n         * @type map<int,TextRect>\n         */\n        this.textSelections = {};\n\n        /**\n         * The text selections converted to a text string which may or may not\n         * be human readable.\n         *\n         * @type {string}\n         */\n        this.text = \"\";\n\n    }\n\n}\n\nclass AreaHighlight extends BaseHighlight {\n\n    constructor(val) {\n\n        super(val);\n\n    }\n\n}\n\n/* abstract */\nclass Annotation extends SerializedObject {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The time this annotation was created\n         * @type ISODateTime\n         */\n        this.created = null;\n\n        /**\n         * The last time this annotation was updated (note changed, moved, etc).\n         * @type ISODateTime\n         */\n        this.lastUpdated = null;\n\n        // TODO: add tags for annotations. This might be overkill but it might\n        // be a good way to manage some of these types.\n\n        this.init(val);\n\n    }\n\n    setup() {\n\n        if(!this.lastUpdated && this.created) {\n            this.lastUpdated = this.created;\n        }\n\n    }\n\n    validate() {\n\n        if(!this.created) {\n            throw new Error(\"Created is required\");\n        }\n\n        // FIXME: move this to validateMembers\n        if(!this.created instanceof ISODateTime) {\n            throw new Error(\"Member created has wrong type: \", typeof this.created);\n        }\n\n        if(!this.lastUpdated instanceof ISODateTime) {\n            throw new Error(\"Member lastUpdated has wrong type: \", typeof this.lastUpdated);\n        }\n\n    }\n\n}\n\n/* abstract */\nclass AnnotationWithNote extends Annotation {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The note for this annotation.\n         *\n         * @type Note\n         */\n        this.notes = {};\n\n        // FIXME: the keys of these objects should be the hash of the time\n        // sequenece, the user, and machine that this was generated on.\n\n        // FIXME: should have comments (plural)\n\n        // FIXME: should have tags (plural)\n\n        // FIXME: should have flashcards (plural) for anki usage.\n\n        this.init(val);\n\n    }\n\n    setup() {\n\n        super.setup();\n\n        if(!this.note) {\n            this.note = new Note({text: \"\", created: this.created});\n        }\n\n    }\n\n    validate() {\n        super.validate();\n    }\n\n}\n\nmodule.exports.PagemarkType = Object.freeze({\n    SINGLE_COLUMN: new Symbol(\"SINGLE_COLUMN\"),\n    DOUBLE_COLUMN: new Symbol(\"DOUBLE_COLUMN\")\n});\n\nmodule.exports.Pagemark = class extends AnnotationWithNote {\n\n    constructor(val) {\n\n        super(val);\n\n        /**\n         * The note for this annotation.\n         *\n         * @type PagemarkType\n         */\n        this.type = null;\n\n        /**\n         * The vertical percentage of the page that is covered with the page\n         * mark.  From 0 to 100.\n         * @type number\n         */\n        this.percentage = null;\n\n        /**\n         * The column number we're working on.\n         *\n         * @type {null}\n         */\n        this.column = null;\n\n        this.init(val);\n\n    }\n\n    setup() {\n\n        super.setup();\n\n        if(!this.type) {\n            this.type = PagemarkType.SINGLE_COLUMN;\n        }\n\n        if(!this.percentage) {\n            this.percentage = 100;\n        }\n\n        if(!this.column) {\n            this.column = 0;\n        }\n\n    }\n\n    validate() {\n        super.validate();\n    }\n\n\n    // toJSON() {\n    //     return MetadataSerializer.serialize(this);\n    // }\n\n    toString() {\n        return MetadataSerializer.serialize(this);\n    }\n\n}\n\n/**\n * All JSON must go through the metadata serializer so we can handle proper\n * serialization but also object validation once they are deserialized.\n */\nmodule.exports.MetadataSerializer = class {\n\n    static replacer(key, value) {\n        if(value instanceof ISODateTime) {\n            return value.toJSON();\n        }\n\n        return value;\n\n    }\n\n    static serialize(object, spacing) {\n        //return JSON.stringify(object, MetadataSerializer.replacer, \"\");\n\n        // FIXME: if this is a SerializedObject, call validate() before we return it\n\n        if (!spacing) {\n            spacing = \"\";\n        }\n\n        return JSON.stringify(object, null, spacing);\n    }\n\n    /**\n     * Given an instance of an object, and a JSON string, deserialize the string into\n     * the object.\n     * @param object\n     * @param data\n     */\n    static deserialize(obj,data) {\n\n        if(!data) {\n            throw new Error(\"No data given!\")\n        }\n\n        let parsed = JSON.parse(data);\n        Object.assign(obj, parsed);\n        return obj;\n    }\n\n}\n\nclass DocMetaWriter {\n\n}\n\n\n//# sourceURL=webpack:///./web/js/metadata/metadata.js?");

/***/ }),

/***/ "./web/js/model.js":
/*!*************************!*\
  !*** ./web/js/model.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst {Pagemark, PagemarkType} = __webpack_require__(/*! ./metadata/metadata.js */ \"./web/js/metadata/metadata.js\");\n\nmodule.exports.Model = class {\n\n    constructor(datastore, clock) {\n\n        this.datastore = datastore;\n        this.clock = clock;\n\n        this.reactor = new Reactor();\n        this.reactor.registerEvent('documentLoaded');\n        this.reactor.registerEvent('createPagemark');\n        this.reactor.registerEvent('erasePagemark');\n\n        // The currently loaded document.\n        this.docMetaPromise = null;\n\n        // FIXME: this.docMeta should go away in favor of docMetaPromise\n        this.docMeta = null;\n\n    }\n\n    /**\n     * Called when a new document has been loaded.\n     */\n    async documentLoaded(fingerprint, nrPages, currentPageNumber) {\n\n        console.log(\"model: New document loaded!\");\n\n        // docMetaPromise is used for future readers after the document is loaded\n        this.docMetaPromise = this.datastore.getDocMeta(fingerprint);\n\n        this.docMeta = await this.docMetaPromise;\n\n        if(this.docMeta == null) {\n            // this is a new document...\n            //this.docMeta = DocMeta.createWithinInitialPagemarks(fingerprint, nrPages);\n            this.docMeta = DocMeta.create(fingerprint, nrPages);\n            this.datastore.sync(fingerprint, this.docMeta);\n        }\n\n        this.reactor.dispatchEvent('documentLoaded', {fingerprint, nrPages, currentPageNumber});\n\n        return this.docMeta;\n\n    }\n\n    // FIXME: remiove this:\n    computeInitialPagemarkPageNumbers(docMeta, nrPages, currentPageNumber) {\n\n        var result = [];\n\n        var range = computeRangeBuffer(currentPageNumber, 3, 1, nrPages);\n\n        for(var pageNum = range.start; pageNum <= range.end; ++pageNum) {\n\n            var pageMeta = docMeta.pageMetas[pageNum];\n\n            forDict(pageMeta.pagemarks, function (pagemarkId, pagemark) {\n                result.push(pageNum);\n            });\n\n        }\n\n        return result;\n\n    }\n\n    registerListenerForDocumentLoaded(eventListener) {\n        this.reactor.addEventListener('documentLoaded', eventListener);\n    }\n\n    /**\n     *\n     * @param pageNum The page num to use for our created pagemark.\n     */\n    async createPagemark(pageNum, options) {\n\n        if(!options) {\n            options = {};\n        }\n\n        if(!options.percentage) {\n            options.percentage = 100;\n        }\n\n        console.log(\"Model sees createPagemark\");\n\n        this.assertPageNum(pageNum);\n\n        // FIXME: determine the type and the column\n\n        // FIXME: just set docMeta pageMarkType = PagemarkType.SINGLE_COLUMN by default.\n\n        let pagemark = new Pagemark({\n            created: this.clock.getDate(),\n            type: PagemarkType.SINGLE_COLUMN,\n            percentage: options.percentage,\n            column: 0\n        });\n\n        let docMeta = await this.docMetaPromise;\n\n        let pageMeta = this.docMeta.getPageMeta(pageNum);\n\n        // set the pagemark that we just created.\n        pageMeta.pagemarks[pagemark.column] = pagemark;\n\n        // FIXME: this can be done with a mutation listener...\n        this.reactor.dispatchEvent('createPagemark', {pageNum, pagemark});\n\n        // FIXME: we need a fingerprint in the docInfo too.\n\n        // TODO: consider only marking the page read once the datastore has\n        //        been written.\n        this.datastore.sync(this.docMeta.docInfo.fingerprint, this.docMeta);\n\n    }\n\n    erasePagemark(pageNum) {\n\n        console.log(\"Model sees erasePagemark\");\n\n        this.assertPageNum(pageNum);\n\n        let pageMeta = this.docMeta.getPageMeta(pageNum);\n\n        pageMeta.pagemarks = {};\n\n        // FIXME: this can be done with a mutation listener...\n        this.reactor.dispatchEvent('erasePagemark', {pageNum});\n\n        // TODO: consider only marking the page read once the datastore has\n        //        been written.\n        this.datastore.sync(this.docMeta.docInfo.fingerprint, this.docMeta);\n\n    }\n\n    createTextHighlight() {\n\n    }\n\n    /**\n     *\n     * @param pageNum\n     */\n    async pageLoaded(pageNum) {\n\n        let docMeta = await this.docMetaPromise;\n        let pageMeta = this.docMeta.getPageMeta(pageNum);\n\n        forDict(pageMeta.pagemarks, function (pagemarkId, pagemark) {\n\n            // FIXME: this is wrong and we should fire with the right\n            // pagemark type.\n\n            // FIXME: this IS working but the document isn't finished\n            // loading yet.  We can SEE that a new document was loaded\n            // but not that it was finished loading...\n\n            console.log(\"Dispatching event to create pagemark for page: \" + pageNum);\n\n            this.reactor.dispatchEvent('createPagemark', {pageNum});\n\n        }.bind(this));\n\n    }\n\n    assertPageNum(pageNum) {\n\n        if(pageNum == null)\n            throw new Error(\"Must specify page pageNum\");\n\n        if(pageNum <= 0) {\n            throw new Error(\"Page numbers begin at 1\");\n        }\n\n    }\n\n    registerListenerForCreatePagemark(eventListener) {\n        this.reactor.addEventListener('createPagemark', eventListener);\n    }\n\n    registerListenerForErasePagemark(eventListener) {\n        this.reactor.addEventListener('erasePagemark', eventListener);\n    }\n\n}\n\n// https://stackoverflow.com/questions/15308371/custom-events-model-without-using-dom-events-in-javascript\n\n// TODO: move this to a util library\n\nclass Event {\n\n    constructor(name) {\n        this.name = name;\n        this.callbacks = [];\n    }\n\n    registerCallback(callback){\n        this.callbacks.push(callback);\n    }\n\n}\n\n// TODO: move this to a util library\n\nclass Reactor {\n\n    constructor() {\n        this.events = {};\n    }\n\n    registerEvent(eventName){\n        var event = new Event(eventName);\n        this.events[eventName] = event;\n    }\n\n    dispatchEvent(eventName, eventArgs){\n        this.events[eventName].callbacks.forEach(function(callback){\n            callback(eventArgs);\n        });\n    }\n\n    addEventListener(eventName, callback){\n        this.events[eventName].registerCallback(callback);\n    }\n\n}\n\n// TODO: move this to a util library\n\n// TODO: move this to a util library\n\n/**\n * Given an integer, compute the first N pages..\n */\nfunction computeRangeBuffer(initial, offset, min, max) {\n    var start = Math.max(min, initial - offset);\n    var end = Math.min(max, initial + offset);\n    return {start, end};\n}\n\n\n\n//# sourceURL=webpack:///./web/js/model.js?");

/***/ }),

/***/ "./web/js/polar.js":
/*!*************************!*\
  !*** ./web/js/polar.js ***!
  \*************************/
/*! exports provided: polar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"polar\", function() { return polar; });\n// const electron = require('electron');\n// const path = require('path');\n// const fs = require('fs');\n\n// basic object around polar state and runtime.\nlet polar = {\n\n    state: {\n\n    }\n\n};\n\n\n\n\n\n//# sourceURL=webpack:///./web/js/polar.js?");

/***/ }),

/***/ "./web/js/text-highlights.js":
/*!***********************************!*\
  !*** ./web/js/text-highlights.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconsole.log(\"FIXME3 module.exports\", module.exports);\n\nconst {TextHighlightView} = __webpack_require__(/*! ./TextHighlightView.js */ \"./web/js/TextHighlightView.js\");\nconst {elementOffset, createSiblingTuples, Elements, Styles} = __webpack_require__(/*! ./utils.js */ \"./web/js/utils.js\");\n\n__webpack_require__(/*! ../../lib/TextHighlighter.js */ \"./lib/TextHighlighter.js\");\n\n\n// code for dealing with text highlights\n\n// given some text, compute a list of rects that can overlap the text to form\n// one coherent highlight.\n\nmodule.exports.TextHighlightController = class {\n\n    constructor(textHighlighter) {\n        this.textHighlighter = textHighlighter;\n    }\n\n    keyBindingListener(event) {\n\n        if (event.ctrlKey && event.altKey) {\n\n            const tCode = 84;\n\n            switch (event.which) {\n\n                case tCode:\n                    this.textHighlighter.doHighlight();\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n    }\n\n    listenForKeyBindings() {\n        document.addEventListener(\"keyup\", this.keyBindingListener.bind(this));\n    }\n\n    static create() {\n\n        return new TextHighlightController(TextHighlightController.createTextHighlighter());\n\n    }\n\n    /**\n     * Set text highlighting in the current document with the highlighter.\n     */\n    static createTextHighlighter() {\n\n        var sequence = 0;\n\n        var textHighlighterOptions = {\n\n            highlightedClass: \"text-highlight-span\",\n            color: '', // this works and the color isn't changed.\n            manual: true,\n\n            onBeforeHighlight: function (range) {\n                //console.log(\"onBeforeHighlight range: \", range);\n                return true;\n            },\n            onAfterHighlight: function (range, highlightElements) {\n                // console.log(\"onAfterHighlight range: \", range);\n                // console.log(\"onAfterHighlight hlts: \", highlightElements);\n\n                let id = sequence++;\n                let highlightClazz = \"text-highlight-\" + id;\n\n                highlightElements.forEach(function (highlightElement) {\n                    //highlightElement.style.color = 'blue';\n                    highlightElement.className = highlightElement.className + \" \" + highlightClazz;\n                });\n\n                // FIXME: use the highlightElements to get the text of the nodes\n                // then compute a hashcode to determine the ID of the highlight.\n\n                TextHighlightRenderer.create(\".\" + highlightClazz);\n\n            },\n\n            onRemoveHighlight: function (hlt) {\n                // console.log(\"onRemoveHighlight hlt: \", hlt);\n            }\n\n        };\n\n        return new TextHighlighter(document.body, textHighlighterOptions);\n\n    }\n\n\n}\n\nclass TextHighlightRenderer {\n\n    constructor(textHighlightRows, selector) {\n        this.textHighlightRows = textHighlightRows;\n        this.selector = selector;\n    }\n\n    static create(selector) {\n\n        let textHighlightRows = TextHighlightRows.createFromSelector(selector);\n\n        let rects = textHighlightRows.map(current => current.rect);\n\n        var textSelections = {}; // FIXME: do this later\n        var text = \"\"; // FIXME: do this later\n\n        let textHighlight = new TextHighlight({rects, textSelections, text});\n\n        // FIXME: this needs to be done in the VIEW and not in the controller...\n\n        // go through each marker and render them.\n        textHighlightRows.forEach(function (textHighlightRow) {\n\n            // This only needs to be done ONCE for the entire row and we just\n            // need the main element for a reference point.\n\n            if(textHighlightRow.rectElements.length > 0) {\n\n                var rectElement = textHighlightRow.rectElements[0];\n\n                // We only need to call render on the first one because the row\n                // has the rect we're using to highlight and we're only using\n                // the element for positioning.\n                this.render(rectElement.element, textHighlightRow.rect);\n\n            }\n\n        }.bind(this));\n\n        return new TextHighlightRenderer(textHighlightRows, selector);\n\n    }\n\n\n    /**\n     * Render a physical highlight on an element for the given rect\n     *\n     * @param element the <span> that was created to hold the text we are going to highlight.\n     * @param highlightRect\n     */\n    static render(element, highlightRect) {\n\n        // FIXME: rework this to take just a PAGE and not have any dependency on\n        // the element as we JUST need to .textLayer\n\n        Elements.requireClass(element, \"text-highlight-span\");\n\n        // this is the overlay element we're goign to paint yellow to show\n        // that we've highlighted the text.\n        var highlightElement = document.createElement(\"div\");\n\n        // this is the 'div' within the textLayer holding the style information\n        // we need to compute offset and location.\n        var textLayerDivElement = element.parentElement;\n\n        // this is the <div class='textLayer'> that holds all the <div> text\n        var textLayerElement = textLayerDivElement.parentElement;\n\n        Elements.requireClass(textLayerElement, \"textLayer\");\n\n        // thisis the holder element which contains .canvasWrapper, .textLayer, etc.\n        var pageElement = textLayerElement.parentElement;\n\n        highlightElement.className = \"text-highlight\";\n\n        highlightElement.style.position = \"absolute\";\n        highlightElement.style.backgroundColor = `yellow`;\n        highlightElement.style.opacity = `0.5`;\n\n        highlightElement.style.left = `${highlightRect.left}px`;\n        highlightElement.style.top = `${highlightRect.top}px`;\n\n        highlightElement.style.width = `${highlightRect.width}px`;\n        highlightElement.style.height = `${highlightRect.height}px`;\n\n\n        // TODO: the problem with this strategy is that it inserts elements in the\n        // REVERSE order they are presented visually.  This isn't a problem but\n        // it might become confusing to debug this issue.  A quick fix is to\n        // just reverse the array before we render the elements.\n        pageElement.insertBefore(highlightElement, pageElement.firstChild);\n\n    }\n\n}\n\n/**\n * The actual annotation that is rendered on the screen plus its reference\n * element so we can redraw when we need to.\n */\nclass TextHighlightAnnotationReference {\n\n\n    constructor(element, highlightRect) {\n        this.element = element;\n        this.highlightRect = highlightRect;\n    }\n\n    render() {\n\n    }\n\n}\n\n\n/**\n * Represents a row of highlighted text including the rect around it, and the\n * elements it contains.\n */\nclass TextHighlightRow {\n\n    constructor(rect, rectElements) {\n        this.rect = rect;\n        this.rectElements = rectElements;\n    }\n\n}\n\n/**\n * TODO:\n *\n * I designed this incorrectly and should refactor it into a problem of geometry.\n *\n * What I need to do is form this into a polygon with points decorating the polygon.\n *\n * Then I need to take the outlier points, which contain all the points inside\n * the plane, then break it down into rows by looking down the polygon vertically\n * and bisecting it until it forms a collection of rectangles.\n *\n * The code for this would be a LOT cleaner and I think less error prone.\n *\n * This wasn't immediately evident because I was thinking about the problem\n * as a stream of text, not of geometric points.\n *\n */\nmodule.exports.TextHighlightRows = class {\n\n    /**\n     * Create a highlight from a CSS selector.\n     */\n    static createFromSelector(selector) {\n\n        let elements = Array.from(document.querySelectorAll(selector));\n\n        if(! elements) {\n            throw new Error(\"No elements\");\n        }\n\n        var rectElements = elements.map(current => this.computeOffset(current));\n\n        let textHighlightRows = TextHighlightRows.computeContiguousRects(rectElements);\n\n        // FIXME: now this is returning TextHighlightRows not TextHighlightRows...\n        // so refactor this to TextHighlightRows.\n\n        return textHighlightRows;\n\n    }\n\n    /**\n     * Given the span of our highlight, compute the offset looking at the CSS\n     * styles of the element we're trying to map.\n     *\n     * @param element The element which we're computing over.\n     * @return A RectElement for the rect (result) and the element\n     */\n    static computeOffset(element) {\n\n        // FIXME... record if this row height is too small!!! this is where the bug is I think...\n\n        // make sure we're working on the right element or our math won't be right.\n        Elements.requireClass(element, \"text-highlight-span\");\n\n        let textHighlightSpanOffset = Elements.offset(element);\n\n        var textLayerDivElement = element.parentElement;\n\n        var textLayerDivOffset = elementOffset(textLayerDivElement);\n        var rect = textLayerDivOffset;\n\n        let scaleX = Styles.parseTransformScaleX(textLayerDivElement.style.transform);\n        if(! scaleX) {\n            scaleX = 1.0;\n        }\n\n        rect.left = rect.left + (textHighlightSpanOffset.left * scaleX);\n        rect.top = rect.top + textHighlightSpanOffset.top;\n\n        rect.height = textHighlightSpanOffset.height;\n        rect.width = textHighlightSpanOffset.width * scaleX;\n\n        rect.width = Math.min(rect.width, textLayerDivOffset.width);\n\n        rect.bottom = rect.top + rect.height;\n        rect.right = rect.left + rect.width;\n\n        return new RectElement(rect, element);\n\n    }\n\n    /**\n     * Go through ALL the rects and build out rows of elements that are\n     * horizontally all on the same plane.\n     *\n     * @param rectElements\n     */\n    static computeRows(rectElements) {\n\n        let tuples = createSiblingTuples(rectElements);\n\n        let result = [];\n\n        // the current row\n        let row = [];\n\n        tuples.forEach(function (tuple) {\n\n            if(!tuple.curr.rect) {\n                throw new Error(\"Not a RectElement\");\n            }\n\n            row.push(tuple.curr);\n\n            if(tuple.next == null || (tuple.next && tuple.curr.rect.top !== tuple.next.rect.top)) {\n                result.push(row);\n                row = [];\n            }\n\n        })\n\n        if (row.length !== 0)\n            result.push(row);\n\n        return result;\n\n    }\n\n    // given a row of rects, compute a rect that covers the entire row maximizing\n    // the height and width.\n    static computeRectForRow(row) {\n\n        if (row.length == null || row.length == 0)\n            throw new Error(\"Invalid row data\");\n\n        // duplicate the first entry... we will keep maximixing the bounds.\n        let result = JSON.parse(JSON.stringify(row[0].rect));\n\n        row.forEach(function (rectElement) {\n\n            if(rectElement.rect.left < result.left) {\n                result.left = rectElement.rect.left;\n            }\n\n            if(rectElement.rect.top < result.top) {\n                result.top = rectElement.rect.top;\n            }\n\n            if(rectElement.rect.bottom > result.bottom) {\n                result.bottom = rectElement.rect.bottom;\n            }\n\n            if(rectElement.rect.right > result.right) {\n                result.right = rectElement.rect.right;\n            }\n\n            result.width = result.right - result.left;\n            result.height = result.bottom - result.top;\n\n        })\n\n        return result;\n\n    }\n\n    static computeIntermediateRows(rectElements) {\n\n        let rows = TextHighlightRows.computeRows(rectElements)\n        let result = [];\n\n        rows.forEach(function (rectElementsWithinRow) {\n            var rect = TextHighlightRows.computeRectForRow(rectElementsWithinRow);\n            let intermediateRow = new IntermediateRow(rect, rectElementsWithinRow);\n            result.push(intermediateRow);\n        });\n\n        return result;\n\n    }\n\n    static computeContiguousRects(rectElements) {\n\n        let intermediateRows = TextHighlightRows.computeIntermediateRows(rectElements);\n\n        let intermediateRowPager = createSiblingTuples(intermediateRows);\n\n        let result = [];\n\n        intermediateRowPager.forEach(function (page) {\n\n            if(!page.curr.rect || !page.curr.rectElements) {\n                throw new Error(\"Not a IntermediateRow\");\n            }\n\n            var adjustedRect = {\n                left: page.curr.rect.left,\n                top: page.curr.rect.top,\n                right: page.curr.rect.right,\n                bottom: page.curr.rect.bottom\n            };\n\n            // adjust the bottom of this div but ONLY if the next div is not on\n            // the same rows.  I might need to have some code to first build\n            // this into ROWS.\n\n            if(page.next && page.next.rect.top != page.curr.rect.top) {\n                adjustedRect.bottom = Math.max(page.next.rect.top, adjustedRect.bottom);\n            }\n\n            adjustedRect.width = adjustedRect.right - adjustedRect.left;\n            adjustedRect.height = adjustedRect.bottom - adjustedRect.top;\n\n            let textHighlightRow = new TextHighlightRow(adjustedRect, page.curr.rectElements);\n\n            result.push(textHighlightRow);\n\n        })\n\n        return result;\n\n    }\n\n}\n\n\n/**\n * A rect and element pair.\n */\nclass RectElement {\n\n    constructor(rect, element) {\n        this.rect = rect;\n        this.element = element;\n    }\n\n}\n\n/**\n * An intermediate row with a rect covering the whole row and the rectElements\n * it contains.\n */\nclass IntermediateRow {\n\n    constructor(rect, rectElements) {\n        this.rect = rect;\n        this.rectElements = rectElements;\n    }\n\n}\n\n\n//# sourceURL=webpack:///./web/js/text-highlights.js?");

/***/ }),

/***/ "./web/js/time/Clock.js":
/*!******************************!*\
  !*** ./web/js/time/Clock.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.Clock = class {\n\n    /**\n     * @return a new Date object representing the current time.\n     */\n    getDate() {\n\n    }\n\n}\n\n\n\n//# sourceURL=webpack:///./web/js/time/Clock.js?");

/***/ }),

/***/ "./web/js/time/SystemClock.js":
/*!************************************!*\
  !*** ./web/js/time/SystemClock.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Clock} = __webpack_require__(/*! ./Clock.js */ \"./web/js/time/Clock.js\");\n\nmodule.exports.SystemClock = class extends Clock {\n\n    getDate() {\n        return new Date();\n    }\n\n}\n\n//# sourceURL=webpack:///./web/js/time/SystemClock.js?");

/***/ }),

/***/ "./web/js/utils.js":
/*!*************************!*\
  !*** ./web/js/utils.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("console.log(\"FIXME3 module.exports\", module.exports);\n\n\n/**\n * Apply a given function, with arguments, to a list of delegates which have\n * that function name defined.\n */\nmodule.exports.Delegator = class {\n\n    constructor(delegates) {\n        this.delegates = delegates;\n    }\n\n    /**\n     * Apply the given function to all the delegates.\n     */\n    apply(functionName) {\n\n        var args = Array.from(arguments);\n        args.splice(0,1);\n\n        this.delegates.forEach(function (delegate) {\n            var func = delegate[functionName];\n            func.apply(delegate, args);\n        });\n    }\n\n}\n\nmodule.exports.forDict = function(dict, callback) {\n\n    if(!dict) {\n        throw new Error(\"dict required\");\n    }\n\n    if(!callback) {\n        throw new Error(\"callback required\");\n    }\n\n    Object.keys(dict).forEach(function (key) {\n        let value = dict[key];\n        callback(key,value);\n    })\n}\n\n/**\n * Get the bounding box for a list of elements, not just one.  This would be\n * the minimum bounding box for all the elements.\n */\nmodule.exports.getBoundingClientRectFromElements = function(elements) {\n\n    var boundingClientRects = elements.map(Element.getBoundingClientRect);\n    return getBoundingClientRectFromBCRs(boundingClientRects);\n\n}\n\n/**\n * Get the bounding box from a list of BCRs.\n */\nmodule.exports.getBoundingClientRectFromBCRs = function(boundingClientRects) {\n\n    var left = boundingClientRects.map((brc) => brc.left).reduce((a,b) => Math.min(a,b));\n    var top = boundingClientRects.map((brc) => brc.top).reduce((a,b) => Math.min(a,b));\n    var bottom = boundingClientRects.map((brc) => brc.bottom).reduce((a,b) => Math.max(a,b));\n    var right = boundingClientRects.map((brc) => brc.right).reduce((a,b) => Math.max(a,b));\n\n    return {left, top, bottom, right};\n\n}\n\n/**\n * Go over the array-like object and return tuples with prev, curr, and next\n * properties so that we can peek at siblings easily.  If the prev and / or next\n * are not present these values are null.\n *\n */\nmodule.exports.createSiblingTuples = function(arr) {\n\n    let result = [];\n\n    for(var idx = 0; idx < arr.length; ++idx) {\n\n        result.push( {\n            curr: arr[idx],\n            prev: Optional.of(arr[idx-1]).getOrElse(null),\n            next: Optional.of(arr[idx+1]).getOrElse(null)\n        });\n\n    }\n\n    return result;\n\n}\n\n/**\n * @Deprecated use Elements.offset instead.\n */\nmodule.exports.elementOffset = function(element) {\n\n    let result = {\n        left: element.offsetLeft,\n        top: element.offsetTop,\n        width: element.offsetWidth,\n        height: element.offsetHeight\n    };\n\n    result.right = result.left + result.width;\n    result.bottom = result.top + result.height;\n\n    return result\n\n}\n\nmodule.exports.Elements = class {\n\n    static offset(element) {\n\n        let result = {\n            left: element.offsetLeft,\n            top: element.offsetTop,\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n\n        result.right = result.left + result.width;\n        result.bottom = result.top + result.height;\n\n        return result\n\n    }\n\n    /**\n     * Require that the element have the given classname.\n     */\n    static requireClass(element, clazz) {\n\n        var classValue = element.getAttribute(\"class\");\n\n        if( ! classValue || classValue.indexOf(clazz) === -1) {\n\n            // element isn't the proper class we're expecting.\n            throw new Error(\"Element does not have the proper class: \" + clazz)\n\n        }\n\n    }\n\n    static offsetRelative(element, parentElement) {\n\n        var offset = {left: 0, top: 0, bottom: 0, right: 0};\n\n        do {\n\n            if ( !isNaN( elem.offsetLeft ) ) {\n                offsetLeft += elem.offsetLeft;\n            }\n\n        } while(element = elem.offsetParent && element != parentElement);\n\n        return offsetLeft;\n\n    }\n\n    /**\n     * Keep searching parent notes until we find an element matching the selector,\n     * or return null when one was not found.\n     *\n     * @param selector\n     */\n    static untilRoot(element, selector) {\n\n        if (!element)\n            throw new Error(\"element required\");\n\n        if (!selector)\n            throw new Error(\"selector required\");\n\n        if(element.matches(selector)) {\n            return element;\n        }\n\n        if (element.parentElement == null) {\n            // we have hit the root.\n            return null;\n        }\n\n        return Elements.untilRoot(element.parentElement, selector);\n\n    }\n\n}\n\n/**\n * Support the ability to calculate an offset relative to another element.\n */\nmodule.exports.OffsetCalculator = class {\n\n    // https://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document\n    static calculate(element, rootElement) {\n\n        var offset = {left: 0, top: 0, width: 0, height: 0};\n\n        while(true) {\n\n            if(element == null)\n                break;\n\n            console.log(\"FIXME: element: \", element);\n            console.log(\"FIXME: has offset: \", Elements.offset(element));\n\n            // FIXME: log the full offsets of EACH element...\n\n            offset.left += OffsetCalculator._toInt(element.offsetLeft)\n            offset.top += OffsetCalculator._toInt(element.offsetTop)\n            // offset.width += OffsetCalculator._toInt(element.offsetWidth)\n            // offset.height += OffsetCalculator._toInt(element.offsetHeight)\n            offset.width = OffsetCalculator._toInt(element.offsetWidth)\n            offset.height = OffsetCalculator._toInt(element.offsetHeight)\n\n            if(element === rootElement)\n                break;\n\n            element = element.offsetParent;\n\n        }\n\n        offset.right = offset.left + offset.width;\n        offset.bottom = offset.top + offset.height;\n\n        return offset;\n\n    }\n\n    static _toInt(value) {\n\n        if ( isNaN( value ) ) {\n            return 0;\n        }\n\n        return value;\n\n    }\n\n}\n\nmodule.exports.Styles = class {\n\n    static parseTransformScaleX(transform) {\n\n        var result = transform;\n\n        if( ! result)\n            return null;\n\n        result = result.replace(\"scaleX(\", \"\");\n        result = result.replace(\")\", \"\");\n\n        return parseFloat(result);\n\n    }\n\n    /**\n     * Take a string of '50px' and return a number of just the pixel count.\n     */\n    static parsePixels(value) {\n\n        value = value.replace(\"px\", \"\");\n        return parseInt(value);\n\n    }\n\n}\n\nmodule.exports.Objects = class {\n\n    static duplicate(obj) {\n          return JSON.parse(JSON.stringify(obj));\n    }\n\n}\n\n\n//# sourceURL=webpack:///./web/js/utils.js?");

/***/ }),

/***/ "./web/js/view/View.js":
/*!*****************************!*\
  !*** ./web/js/view/View.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\nmodule.exports.View = class {\n\n    constructor(model) {\n        this.model = model;\n    }\n\n};\n\n\n\n//# sourceURL=webpack:///./web/js/view/View.js?");

/***/ }),

/***/ "./web/js/view/WebView.js":
/*!********************************!*\
  !*** ./web/js/view/WebView.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Delegator, Styles, Elements, forDict} = __webpack_require__(/*! ../utils.js */ \"./web/js/utils.js\");\nconst {DocMetaDescriber} = __webpack_require__(/*! ../metadata/metadata.js */ \"./web/js/metadata/metadata.js\");\nconst {View} = __webpack_require__(/*! ./View.js */ \"./web/js/view/View.js\");\n\nmodule.exports.WebView = class extends View {\n\n    constructor(model) {\n        super(model);\n\n        /**\n         * The currently defined renderer for pagemarks.\n         */\n        this.pagemarkRenderer = null;\n\n    }\n\n    init() {\n\n        this.model.registerListenerForCreatePagemark(this.onCreatePagemark.bind(this));\n        this.model.registerListenerForErasePagemark(this.onErasePagemark.bind(this));\n        this.model.registerListenerForDocumentLoaded(this.onDocumentLoaded.bind(this));\n\n        return this;\n\n    }\n\n    updateProgress() {\n\n        var perc = this.computeProgress(this.model.docMeta);\n\n        console.log(\"Percentage is now: \" + perc);\n\n        document.querySelector(\"#pagemark-process\").value = perc;\n\n        // now update the description of the doc at the bottom.\n\n        var description = DocMetaDescriber.describe(this.model.docMeta);\n\n        document.querySelector(\"#polar-doc-overview\").textContent = description;\n\n    }\n\n    computeProgress(docMeta) {\n\n        // I think this is an issue of being async maybel?\n\n        var total = 0;\n\n        // TODO: this isn't going to work with multiple columns...\n\n        console.log(docMeta.pageMetas);\n\n        forDict(docMeta.pageMetas, function (key, pageMeta) {\n\n            forDict(pageMeta.pagemarks, function (column, pagemark) {\n\n                total += pagemark.percentage;\n\n            }.bind(this));\n\n        }.bind(this));\n\n        var perc = total / (docMeta.docInfo.nrPages * 100);\n\n        return perc;\n    }\n\n    /**\n     * Setup a document once we detect that a new one has been loaded.\n     */\n    onDocumentLoaded() {\n\n        console.log(\"WebView.onDocumentLoaded\");\n\n        var pagemarkRendererDelegates = [\n            new MainPagemarkRenderer(this),\n            new ThumbnailPagemarkRenderer(this)\n        ];\n\n        this.pagemarkRenderer = new CompositePagemarkRenderer(this, pagemarkRendererDelegates);\n        this.pagemarkRenderer.setup();\n\n        this.updateProgress();\n\n    }\n\n    getPageElementByNum(num) {\n\n        if(!num) {\n            throw new Error(\"Page number not specified\");\n        }\n\n        var pageElements = document.querySelectorAll(\".page\");\n\n        // note that elements are 0 based indexes but our pages are 1 based\n        // indexes.\n        var pageElement = pageElements[num - 1];\n\n        if(pageElement == null) {\n            throw new Error(\"Unable to find page element for page num: \" + num);\n        }\n\n        return pageElement;\n\n    }\n\n    onCreatePagemark(pagemarkEvent) {\n\n        console.log(\"Creating pagemark on page: \" + pagemarkEvent.pageNum);\n\n        //this.createPagemark(this.getPageElementByNum(pageEvent.num));\n\n        this.pagemarkRenderer.create(pagemarkEvent.pageNum, pagemarkEvent.pagemark);\n        this.updateProgress();\n\n    }\n\n    onErasePagemark(pagemarkEvent) {\n        console.log(\"Erasing pagemark\");\n\n        //let pageElement = this.getPageElementByNum(pageEvent.num);\n        //this.erasePagemarks(pageElement);\n\n        this.pagemarkRenderer.erase(pagemarkEvent.pageNum);\n        this.updateProgress();\n\n    }\n\n    async recreatePagemarksFromPagemarks(pageElement, options) {\n\n        var pageNum = this.getPageNum(pageElement);\n\n        var docMeta = this.model.docMeta;\n\n        var pageMeta = docMeta.pageMetas[pageNum];\n\n        forDict(pageMeta.pagemarks, function (column, pagemark) {\n\n            console.log(\"Creating pagemarks for page: \" + pageNum);\n\n            var recreatePagemarkOptions = Object.assign({}, options);\n\n            recreatePagemarkOptions.pagemark = pagemark;\n\n            this.recreatePagemark(pageElement, recreatePagemarkOptions);\n\n        }.bind(this));\n\n        //this.recreatePagemark(pageElement);\n\n    }\n\n    getPageNum(pageElement) {\n        let dataPageNum = pageElement.getAttribute(\"data-page-number\");\n        return parseInt(dataPageNum);\n    }\n\n    recreatePagemark(pageElement, options) {\n\n        if(! options.pagemark) {\n            throw new Error(\"No pagemark.\");\n        }\n\n        if( pageElement.querySelector(\".pagemark\") != null &&\n            pageElement.querySelector(\".canvasWrapper\") != null &&\n            pageElement.querySelector(\".textLayer\") != null ) {\n\n            // Do not recreate the pagemark if:\n            //   - we have a .pagemark element\n            //   - we also have a .canvasWrapper and a .textLayer\n\n            return;\n\n        }\n\n        // make sure to first remove all the existing pagemarks if there\n        // are any\n        this.erasePagemarks(pageElement);\n\n        // we're done all the canvas and text nodes... so place the pagemark\n        // back in again.\n\n        this.createPagemark(pageElement, options);\n\n    }\n\n    /**\n     * Create a pagemark on the given page which marks it read.\n     * @param pageElement\n     */\n    createPagemark(pageElement, options) {\n\n        if(! options) {\n            throw new Error(\"Options are required\");\n        }\n\n        if(! options.pagemark) {\n            throw new Error(\"Pagemark is required\");\n        }\n\n        if(! options.pagemark.percentage) {\n            throw new Error(\"Pagemark has no percentage\");\n        }\n\n        if(! options.zIndex)\n            options.zIndex = 0;\n\n        if(! options.templateElement) {\n            options.templateElement = pageElement;\n        }\n\n        if (! options.placementElement) {\n            // TODO: move this to the object dealing with pages only.\n            options.placementElement = pageElement.querySelector(\".canvasWrapper\");\n        }\n\n        if(! options.templateElement) {\n            throw new Error(\"No templateElement\");\n        }\n\n        if(! options.placementElement) {\n            throw new Error(\"No placementElement\");\n        }\n\n        if (pageElement.querySelector(\".pagemark\")) {\n            // do nothing if the current page already has a pagemark.\n            console.warn(\"Pagemark already exists\");\n            return;\n        }\n\n        let pagemark = document.createElement(\"div\");\n\n        // make sure we have a reliable CSS classname to work with.\n        pagemark.className=\"pagemark\";\n\n        // set CSS style\n\n        //pagemark.style.backgroundColor=\"rgb(198, 198, 198)\";\n        pagemark.style.backgroundColor=\"#00CCFF\";\n        pagemark.style.opacity=\"0.3\";\n\n        pagemark.style.position=\"absolute\";\n        pagemark.style.left = options.templateElement.offsetLeft;\n        pagemark.style.top = options.templateElement.offsetTop;\n        pagemark.style.width = options.templateElement.style.width;\n\n        // FIXME: the height should actually be a percentage of the pagemark\n        // percentage.\n\n        var height = Styles.parsePixels(options.templateElement.style.height);\n\n        // FIXME: read the percentate coverage from the pagemark and adjust the\n        // height to reflect the portion we've actually read.\n        height = height * (options.pagemark.percentage / 100);\n\n        pagemark.style.height = `${height}px`;\n\n        pagemark.style.zIndex = options.zIndex;\n\n        if(!pagemark.style.width)\n            throw new Error(\"Could not determine width\");\n\n        options.placementElement.parentElement.insertBefore(pagemark, options.placementElement);\n\n    }\n\n    redrawPagemark() {\n\n    }\n\n    erasePagemarks(pageElement) {\n\n        if(!pageElement) {\n            throw new Error(\"No pageElement\");\n        }\n\n        console.log(\"Erasing pagemarks...\");\n\n        let pagemarks = pageElement.querySelectorAll(\".pagemark\");\n\n        pagemarks.forEach(function (pagemark) {\n            pagemark.parentElement.removeChild(pagemark);\n            console.log(\"Erased pagemark.\");\n        });\n\n        console.log(\"Erasing pagemarks...done\");\n\n    }\n\n}\n\n/**\n *\n */\nclass PagemarkRenderer {\n\n    constructor(view) {\n        this.view = view;\n        this.pageElements = [];\n\n        // the CSS selector for pulling out the right pageElements.\n        this.pageElementSelector = null;\n    }\n\n    setup() {\n\n    }\n\n    __setup() {\n\n        // FIXME: now we need a way to clear a given page by keeping a reference\n        // to the page renderer for that page and then call erase on it once it\n        // has been removed.\n\n        this.__updatePageElements();\n\n        console.log(`Working with ${this.pageElements.length} elements for selector ${this.pageElementSelector}` );\n\n        this.pageElements.forEach( function (pageElement) {\n            this.init(pageElement);\n        }.bind(this));\n\n    }\n\n    __updatePageElements() {\n        this.pageElements = document.querySelectorAll(this.pageElementSelector);\n    }\n\n    init(pageElement) {\n\n        if(this.__requiresPagemark(pageElement)) {\n            this.__render(pageElement);\n        }\n\n        this.__registerListener(pageElement);\n\n    }\n\n    /**\n     * Return true if the target needs a pagemark.\n     */\n    __requiresPagemark(pageElement) {\n\n    }\n\n    /**\n     * Register future listeners to monitor status.\n     */\n    __registerListener(pageElement) {\n\n    }\n\n    __render(pageElement) {\n    }\n\n    /**\n     * Erase the page elements on the give page number.\n     */\n    create(pageNum, pagemark) {\n\n        if(typeof pageNum !== \"number\") {\n            throw new Error(\"pageNum is not a number\");\n        }\n\n        if(!pagemark) {\n            throw new Error(\"No pagemark.\");\n        }\n\n        this.__updatePageElements();\n\n        var pageElement = this.pageElements[pageNum-1];\n\n        if(!pageElement) {\n            throw new Error(`No pageElement for pageNum ${pageNum} out of ${this.pageElements.length} pageElements`);\n        }\n\n        this.__render(pageElement);\n    }\n\n    /**\n     * Erase the pagemarks on the give page number.\n     */\n    erase(pageNum) {\n\n        if(typeof pageNum !== \"number\") {\n            throw new Error(\"pageNum is not a number\");\n        }\n\n        this.__updatePageElements();\n\n        var pageElement = this.pageElements[pageNum-1];\n\n        if(!pageElement) {\n            throw new Error(`No pageElement for pageNum ${pageNum} out of ${this.pageElements.length} pageElements`);\n        }\n\n        this.view.erasePagemarks(pageElement);\n    }\n\n}\n\n/**\n * Handles attaching pagemarks to the pages (as opposed to thumbnails).\n */\nclass MainPagemarkRenderer extends PagemarkRenderer {\n\n    constructor(view) {\n        super(view);\n        this.pageElementSelector = \".page\";\n\n    }\n\n    setup() {\n        this.__setup();\n    }\n\n    __requiresPagemark(pageElement) {\n        return pageElement.querySelector(\"canvas\") != null;\n    }\n\n    __registerListener(pageElement) {\n\n        pageElement.addEventListener('DOMNodeInserted', function(event) {\n\n            if (event.target && event.target.className === \"endOfContent\") {\n                this.__render(pageElement);\n            }\n\n        }.bind(this), false );\n\n    }\n\n    __render(pageElement) {\n        this.view.recreatePagemarksFromPagemarks(pageElement);\n    }\n\n}\n\n/**\n * Handles attaching pagemarks to the pages (as opposed to thumbnails).\n */\nclass ThumbnailPagemarkRenderer extends PagemarkRenderer {\n\n    constructor(view) {\n        super(view);\n        this.pageElementSelector = \".thumbnail\";\n    }\n\n    setup() {\n        this.__setup();\n    }\n\n    __requiresPagemark(pageElement) {\n        let thumbnailImage = pageElement.querySelector(\".thumbnailImage\");\n        return thumbnailImage != null && thumbnailImage.getAttribute(\"src\") != null;\n    }\n\n    __registerListener(pageElement) {\n\n        pageElement.querySelector(\".thumbnailSelectionRing\").addEventListener('DOMNodeInserted', function(event) {\n\n            if (event.target && event.target.className === \"thumbnailImage\") {\n                this.__render(pageElement);\n            }\n\n        }.bind(this), false );\n\n    }\n\n    __render(pageElement) {\n\n        var templateElement = pageElement.querySelector(\".thumbnailImage\");\n\n        if( ! templateElement) {\n            // the thumbnail tab might not be visible.\n            return;\n        }\n\n        var options = {zIndex: 1, templateElement, placementElement: templateElement};\n\n        this.view.recreatePagemarksFromPagemarks(pageElement, options);\n\n    }\n\n}\n\nclass CompositePagemarkRenderer extends PagemarkRenderer {\n\n    constructor(view, delegates) {\n        super(view);\n\n        if(!delegates) {\n            throw new Error(\"No delegates\");\n        }\n\n        this.delegator = new Delegator(delegates);\n    }\n\n    setup() {\n        this.delegator.apply(\"setup\");\n    }\n\n    create(pageNum, pagemark) {\n        this.delegator.apply(\"create\", pageNum, pagemark);\n    }\n\n    erase(pageNum) {\n        this.delegator.apply(\"erase\", pageNum);\n    }\n\n}\n\n\n//# sourceURL=webpack:///./web/js/view/WebView.js?");

/***/ })

/******/ });